
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://fightingff.github.io/notebooks/Database/">
      
      
        <link rel="prev" href="../Info/">
      
      
        <link rel="next" href="../RiscV/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.21">
    
    
      
        <title>Database - FF's Notebooks</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.66ac8b77.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../stylesheets/extra.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#database" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="FF&#39;s Notebooks" class="md-header__button md-logo" aria-label="FF's Notebooks" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            FF's Notebooks
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Database
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/fightingff/notebooks" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    fightingff/notebooks
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="FF&#39;s Notebooks" class="md-nav__button md-logo" aria-label="FF's Notebooks" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    FF's Notebooks
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/fightingff/notebooks" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    fightingff/notebooks
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Home
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="https://isshikihugh.github.io/zju-cs-asio/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ZJU CS Masters' Notes
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Courses
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Courses
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    大一
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            大一
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ASM/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    x86 Asm
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    大二上
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            大二上
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../DigitLogic/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Digit Logic Design
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../CS231n/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    CS 231n
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
    
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    大二下
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            大二下
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../ADS/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    ADS
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../OOP/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    OOP
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Info/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Information Theory
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Database
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Database
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      第一章 引入
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第一章 引入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      数据库重要问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      系统结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      数据库语言
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      第二章 数据库概念
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第二章 数据库概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      概念引入
    </span>
  </a>
  
    <nav class="md-nav" aria-label="概念引入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#table" class="md-nav__link">
    <span class="md-ellipsis">
      Table
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relation" class="md-nav__link">
    <span class="md-ellipsis">
      Relation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key" class="md-nav__link">
    <span class="md-ellipsis">
      Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schema-diagram" class="md-nav__link">
    <span class="md-ellipsis">
      Schema Diagram
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      关系代数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关系代数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      基础操作
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    <span class="md-ellipsis">
      第三章 SQL基础
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三章 SQL基础">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql_1" class="md-nav__link">
    <span class="md-ellipsis">
      SQL数据类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql_2" class="md-nav__link">
    <span class="md-ellipsis">
      SQL语句
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SQL语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#updates-to-tables" class="md-nav__link">
    <span class="md-ellipsis">
      Updates to tables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    <span class="md-ellipsis">
      select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as" class="md-nav__link">
    <span class="md-ellipsis">
      as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    <span class="md-ellipsis">
      string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aggregate-functions" class="md-nav__link">
    <span class="md-ellipsis">
      aggregate functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    <span class="md-ellipsis">
      group by
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where-having" class="md-nav__link">
    <span class="md-ellipsis">
      where / having
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with" class="md-nav__link">
    <span class="md-ellipsis">
      with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    <span class="md-ellipsis">
      delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    <span class="md-ellipsis">
      update
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql_3" class="md-nav__link">
    <span class="md-ellipsis">
      第四章 SQL进阶
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第四章 SQL进阶">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#join" class="md-nav__link">
    <span class="md-ellipsis">
      Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#view" class="md-nav__link">
    <span class="md-ellipsis">
      View
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    <span class="md-ellipsis">
      Index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integrity-constraint" class="md-nav__link">
    <span class="md-ellipsis">
      Integrity Constraint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      特殊数据类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      权限
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql_4" class="md-nav__link">
    <span class="md-ellipsis">
      第五章 高级SQL
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第五章 高级SQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql-injection" class="md-nav__link">
    <span class="md-ellipsis">
      SQL Injection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stored-procedure" class="md-nav__link">
    <span class="md-ellipsis">
      Stored Procedure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trigger" class="md-nav__link">
    <span class="md-ellipsis">
      Trigger
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      第六章 数据库设计范式一
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第六章 数据库设计范式一">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#design-phases" class="md-nav__link">
    <span class="md-ellipsis">
      Design phases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-alternatives" class="md-nav__link">
    <span class="md-ellipsis">
      Design Alternatives
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#e-r-diagram" class="md-nav__link">
    <span class="md-ellipsis">
      E-R Diagram
    </span>
  </a>
  
    <nav class="md-nav" aria-label="E-R Diagram">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#e-r" class="md-nav__link">
    <span class="md-ellipsis">
      特殊的E-R图
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reduction-to-relational-schemas" class="md-nav__link">
    <span class="md-ellipsis">
      Reduction to Relational Schemas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      第七章 数据库设计范式二
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第七章 数据库设计范式二">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#function-dependency" class="md-nav__link">
    <span class="md-ellipsis">
      Function Dependency
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Function Dependency">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#closure-of-function" class="md-nav__link">
    <span class="md-ellipsis">
      Closure of Function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closure-of-attribute" class="md-nav__link">
    <span class="md-ellipsis">
      Closure of Attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#canonical-cover" class="md-nav__link">
    <span class="md-ellipsis">
      Canonical Cover
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lossless-join-decomposition" class="md-nav__link">
    <span class="md-ellipsis">
      Lossless(-join) Decomposition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependancy-presevation" class="md-nav__link">
    <span class="md-ellipsis">
      Dependancy Presevation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      第三范式
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三范式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      三大范式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      定义：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3nf" class="md-nav__link">
    <span class="md-ellipsis">
      3NF 检查
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3nf_1" class="md-nav__link">
    <span class="md-ellipsis">
      分解为3NF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcnfboyce-codd-normal-form" class="md-nav__link">
    <span class="md-ellipsis">
      BCNF(Boyce-Codd Normal Form)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BCNF(Boyce-Codd Normal Form)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcnf" class="md-nav__link">
    <span class="md-ellipsis">
      检查BCNF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcnf_1" class="md-nav__link">
    <span class="md-ellipsis">
      分解为BCNF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4nf" class="md-nav__link">
    <span class="md-ellipsis">
      多值依赖 &amp; 4NF
    </span>
  </a>
  
    <nav class="md-nav" aria-label="多值依赖 & 4NF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      多值依赖
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4nf_1" class="md-nav__link">
    <span class="md-ellipsis">
      4NF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#more" class="md-nav__link">
    <span class="md-ellipsis">
      More
    </span>
  </a>
  
    <nav class="md-nav" aria-label="More">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#more-nfs" class="md-nav__link">
    <span class="md-ellipsis">
      More NFs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal-data" class="md-nav__link">
    <span class="md-ellipsis">
      Temporal data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#how-to-find-candidate-key" class="md-nav__link">
    <span class="md-ellipsis">
      How to Find Candidate Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-guidelines" class="md-nav__link">
    <span class="md-ellipsis">
      Design Guidelines
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      十二章 物理储存介质
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十二章 物理储存介质">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      储存的评价
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      储存的分类
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      磁盘性能评价
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      十三章 数据储存结构
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十三章 数据储存结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      单条记录
    </span>
  </a>
  
    <nav class="md-nav" aria-label="单条记录">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      定长数据
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      不定长数据
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      数据页
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      文件组织
    </span>
  </a>
  
    <nav class="md-nav" aria-label="文件组织">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#heap" class="md-nav__link">
    <span class="md-ellipsis">
      Heap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" class="md-nav__link">
    <span class="md-ellipsis">
      Sequential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multitable-clustering" class="md-nav__link">
    <span class="md-ellipsis">
      Multitable Clustering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#table-partitioning" class="md-nav__link">
    <span class="md-ellipsis">
      Table Partitioning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-tree-file-index" class="md-nav__link">
    <span class="md-ellipsis">
      B+ Tree File Index
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-dictionarysystem-catalog-storage" class="md-nav__link">
    <span class="md-ellipsis">
      Data Dictionary（System Catalog） Storage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffer-management" class="md-nav__link">
    <span class="md-ellipsis">
      Buffer Management
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Buffer Management">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pin" class="md-nav__link">
    <span class="md-ellipsis">
      Pin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    <span class="md-ellipsis">
      Lock
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffer-replacement" class="md-nav__link">
    <span class="md-ellipsis">
      Buffer Replacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#force-output" class="md-nav__link">
    <span class="md-ellipsis">
      Force Output
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      十四章 索引
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十四章 索引">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      顺序/无序索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      稠密/稀疏索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#composite-search-key" class="md-nav__link">
    <span class="md-ellipsis">
      多值索引（Composite Search Key）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    <span class="md-ellipsis">
      B+树索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      相关优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash" class="md-nav__link">
    <span class="md-ellipsis">
      Hash索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitmap" class="md-nav__link">
    <span class="md-ellipsis">
      Bitmap索引
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      十五章 查询操作
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十五章 查询操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#selection" class="md-nav__link">
    <span class="md-ellipsis">
      Selection
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Selection">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equations" class="md-nav__link">
    <span class="md-ellipsis">
      Equations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison" class="md-nav__link">
    <span class="md-ellipsis">
      Comparison
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjunction" class="md-nav__link">
    <span class="md-ellipsis">
      Conjunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disjunction" class="md-nav__link">
    <span class="md-ellipsis">
      Disjunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitmap-index-scan" class="md-nav__link">
    <span class="md-ellipsis">
      Bitmap Index Scan
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#external-sort" class="md-nav__link">
    <span class="md-ellipsis">
      External Sort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_1" class="md-nav__link">
    <span class="md-ellipsis">
      Join
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Join">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Block Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexed-nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Indexed Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sort-merge-join" class="md-nav__link">
    <span class="md-ellipsis">
      Sort-Merge Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-join" class="md-nav__link">
    <span class="md-ellipsis">
      Hash Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-join" class="md-nav__link">
    <span class="md-ellipsis">
      Complex Join
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Other Operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expression" class="md-nav__link">
    <span class="md-ellipsis">
      Expression
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#materialization" class="md-nav__link">
    <span class="md-ellipsis">
      Materialization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      Pipeline
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      十六章 查询优化
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十六章 查询优化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Equivalence Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#statistical-cost-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Statistical Cost Estimation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Statistical Cost Estimation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#histogram" class="md-nav__link">
    <span class="md-ellipsis">
      Histogram
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selection-size-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Selection Size Estimation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join-size-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Join Size Estimation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-estimations" class="md-nav__link">
    <span class="md-ellipsis">
      Other Estimations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estimation-of-distinct-value" class="md-nav__link">
    <span class="md-ellipsis">
      Estimation of Distinct Value
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cost-base-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Cost Base Optimize
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cost Base Optimize">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#join-order-selection" class="md-nav__link">
    <span class="md-ellipsis">
      Join-Order Selection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cost-based-optimization-with-equivalence-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Cost Based Optimization with Equivalence Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heuristic-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Heuristic Optimize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nested-subqueries-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Nested Subqueries Optimize
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#materialized-view" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Materialized View">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#materialized-view-maintenance" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View Maintenance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#query-optimization" class="md-nav__link">
    <span class="md-ellipsis">
      Query Optimization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#materialized-view-selection" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View Selection
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#transaction" class="md-nav__link">
    <span class="md-ellipsis">
      十七章 Transaction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十七章 Transaction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acid" class="md-nav__link">
    <span class="md-ellipsis">
      ACID 原则
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      并发控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="并发控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#serializability" class="md-nav__link">
    <span class="md-ellipsis">
      Serializability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recoverable-schedule" class="md-nav__link">
    <span class="md-ellipsis">
      Recoverable Schedule
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trade-off" class="md-nav__link">
    <span class="md-ellipsis">
      Trade Off
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      十八章 并发控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十八章 并发控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lock-based-protocols" class="md-nav__link">
    <span class="md-ellipsis">
      Lock-Based Protocols
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lock-Based Protocols">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      内部实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      常见问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#two-phase-lock-protocols" class="md-nav__link">
    <span class="md-ellipsis">
      Two-phase Lock Protocols
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tree-based-protocol-in-graph-based-protocol" class="md-nav__link">
    <span class="md-ellipsis">
      Tree-Based Protocol (\(\in\) Graph-Based Protocol)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handling-deadlock" class="md-nav__link">
    <span class="md-ellipsis">
      Handling Deadlock
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Handling Deadlock">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      死锁预防
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      检测死锁
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      死锁恢复
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-granularity" class="md-nav__link">
    <span class="md-ellipsis">
      Multiple Granularity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-operations_1" class="md-nav__link">
    <span class="md-ellipsis">
      Other Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Other Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#insertdelete" class="md-nav__link">
    <span class="md-ellipsis">
      Insert/Delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicate-reads" class="md-nav__link">
    <span class="md-ellipsis">
      Predicate Reads
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#log-based-recovery" class="md-nav__link">
    <span class="md-ellipsis">
      十九章 错误恢复（Log-Based Recovery）
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十九章 错误恢复（Log-Based Recovery）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      错误类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      日志
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      日志恢复
    </span>
  </a>
  
    <nav class="md-nav" aria-label="日志恢复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check-point" class="md-nav__link">
    <span class="md-ellipsis">
      Check Point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#undoredo" class="md-nav__link">
    <span class="md-ellipsis">
      Undo/Redo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers" class="md-nav__link">
    <span class="md-ellipsis">
      Buffers
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      磁盘恢复
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#undo" class="md-nav__link">
    <span class="md-ellipsis">
      锁的提前释放和逻辑Undo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ARIES">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#physiological-redoredo" class="md-nav__link">
    <span class="md-ellipsis">
      Physiological Redo（物理逻辑Redo）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries-data-structure" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES Data Structure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries_1" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES具体步骤
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      基于主存储的恢复
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../RiscV/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Computer Organization
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Tools
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Tools
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Git/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Git
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../Make/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Makefile & CMake
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
        
          
          <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Materials
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_5">
            <span class="md-nav__icon md-icon"></span>
            Materials
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../AI_Materials/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    AI Materials
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="https://github.com/fightingff/AI" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    My AI Repository
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      第一章 引入
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第一章 引入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      数据库重要问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      系统结构
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      数据库语言
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    <span class="md-ellipsis">
      第二章 数据库概念
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第二章 数据库概念">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    <span class="md-ellipsis">
      概念引入
    </span>
  </a>
  
    <nav class="md-nav" aria-label="概念引入">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#table" class="md-nav__link">
    <span class="md-ellipsis">
      Table
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relation" class="md-nav__link">
    <span class="md-ellipsis">
      Relation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#key" class="md-nav__link">
    <span class="md-ellipsis">
      Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#schema-diagram" class="md-nav__link">
    <span class="md-ellipsis">
      Schema Diagram
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    <span class="md-ellipsis">
      关系代数
    </span>
  </a>
  
    <nav class="md-nav" aria-label="关系代数">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    <span class="md-ellipsis">
      基础操作
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql" class="md-nav__link">
    <span class="md-ellipsis">
      第三章 SQL基础
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三章 SQL基础">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql_1" class="md-nav__link">
    <span class="md-ellipsis">
      SQL数据类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sql_2" class="md-nav__link">
    <span class="md-ellipsis">
      SQL语句
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SQL语句">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#updates-to-tables" class="md-nav__link">
    <span class="md-ellipsis">
      Updates to tables
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#select" class="md-nav__link">
    <span class="md-ellipsis">
      select
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#as" class="md-nav__link">
    <span class="md-ellipsis">
      as
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#string" class="md-nav__link">
    <span class="md-ellipsis">
      string
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#set" class="md-nav__link">
    <span class="md-ellipsis">
      set
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aggregate-functions" class="md-nav__link">
    <span class="md-ellipsis">
      aggregate functions
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#group-by" class="md-nav__link">
    <span class="md-ellipsis">
      group by
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#where-having" class="md-nav__link">
    <span class="md-ellipsis">
      where / having
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with" class="md-nav__link">
    <span class="md-ellipsis">
      with
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#delete" class="md-nav__link">
    <span class="md-ellipsis">
      delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#insert" class="md-nav__link">
    <span class="md-ellipsis">
      insert
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#update" class="md-nav__link">
    <span class="md-ellipsis">
      update
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql_3" class="md-nav__link">
    <span class="md-ellipsis">
      第四章 SQL进阶
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第四章 SQL进阶">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#join" class="md-nav__link">
    <span class="md-ellipsis">
      Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#view" class="md-nav__link">
    <span class="md-ellipsis">
      View
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    <span class="md-ellipsis">
      Index
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#integrity-constraint" class="md-nav__link">
    <span class="md-ellipsis">
      Integrity Constraint
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    <span class="md-ellipsis">
      特殊数据类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    <span class="md-ellipsis">
      权限
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sql_4" class="md-nav__link">
    <span class="md-ellipsis">
      第五章 高级SQL
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第五章 高级SQL">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#sql-injection" class="md-nav__link">
    <span class="md-ellipsis">
      SQL Injection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#stored-procedure" class="md-nav__link">
    <span class="md-ellipsis">
      Stored Procedure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trigger" class="md-nav__link">
    <span class="md-ellipsis">
      Trigger
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    <span class="md-ellipsis">
      第六章 数据库设计范式一
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第六章 数据库设计范式一">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#design-phases" class="md-nav__link">
    <span class="md-ellipsis">
      Design phases
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-alternatives" class="md-nav__link">
    <span class="md-ellipsis">
      Design Alternatives
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#e-r-diagram" class="md-nav__link">
    <span class="md-ellipsis">
      E-R Diagram
    </span>
  </a>
  
    <nav class="md-nav" aria-label="E-R Diagram">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#e-r" class="md-nav__link">
    <span class="md-ellipsis">
      特殊的E-R图
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reduction-to-relational-schemas" class="md-nav__link">
    <span class="md-ellipsis">
      Reduction to Relational Schemas
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    <span class="md-ellipsis">
      第七章 数据库设计范式二
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第七章 数据库设计范式二">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#function-dependency" class="md-nav__link">
    <span class="md-ellipsis">
      Function Dependency
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Function Dependency">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#closure-of-function" class="md-nav__link">
    <span class="md-ellipsis">
      Closure of Function
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#closure-of-attribute" class="md-nav__link">
    <span class="md-ellipsis">
      Closure of Attribute
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#canonical-cover" class="md-nav__link">
    <span class="md-ellipsis">
      Canonical Cover
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lossless-join-decomposition" class="md-nav__link">
    <span class="md-ellipsis">
      Lossless(-join) Decomposition
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dependancy-presevation" class="md-nav__link">
    <span class="md-ellipsis">
      Dependancy Presevation
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    <span class="md-ellipsis">
      第三范式
    </span>
  </a>
  
    <nav class="md-nav" aria-label="第三范式">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    <span class="md-ellipsis">
      三大范式
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    <span class="md-ellipsis">
      定义：
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3nf" class="md-nav__link">
    <span class="md-ellipsis">
      3NF 检查
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3nf_1" class="md-nav__link">
    <span class="md-ellipsis">
      分解为3NF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcnfboyce-codd-normal-form" class="md-nav__link">
    <span class="md-ellipsis">
      BCNF(Boyce-Codd Normal Form)
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BCNF(Boyce-Codd Normal Form)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#bcnf" class="md-nav__link">
    <span class="md-ellipsis">
      检查BCNF
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcnf_1" class="md-nav__link">
    <span class="md-ellipsis">
      分解为BCNF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4nf" class="md-nav__link">
    <span class="md-ellipsis">
      多值依赖 &amp; 4NF
    </span>
  </a>
  
    <nav class="md-nav" aria-label="多值依赖 & 4NF">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    <span class="md-ellipsis">
      多值依赖
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#4nf_1" class="md-nav__link">
    <span class="md-ellipsis">
      4NF
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#more" class="md-nav__link">
    <span class="md-ellipsis">
      More
    </span>
  </a>
  
    <nav class="md-nav" aria-label="More">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#more-nfs" class="md-nav__link">
    <span class="md-ellipsis">
      More NFs
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#temporal-data" class="md-nav__link">
    <span class="md-ellipsis">
      Temporal data
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#how-to-find-candidate-key" class="md-nav__link">
    <span class="md-ellipsis">
      How to Find Candidate Key
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#design-guidelines" class="md-nav__link">
    <span class="md-ellipsis">
      Design Guidelines
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    <span class="md-ellipsis">
      十二章 物理储存介质
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十二章 物理储存介质">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    <span class="md-ellipsis">
      储存的评价
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    <span class="md-ellipsis">
      储存的分类
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    <span class="md-ellipsis">
      磁盘性能评价
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    <span class="md-ellipsis">
      十三章 数据储存结构
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十三章 数据储存结构">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    <span class="md-ellipsis">
      单条记录
    </span>
  </a>
  
    <nav class="md-nav" aria-label="单条记录">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    <span class="md-ellipsis">
      定长数据
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    <span class="md-ellipsis">
      不定长数据
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    <span class="md-ellipsis">
      数据页
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    <span class="md-ellipsis">
      文件组织
    </span>
  </a>
  
    <nav class="md-nav" aria-label="文件组织">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#heap" class="md-nav__link">
    <span class="md-ellipsis">
      Heap
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" class="md-nav__link">
    <span class="md-ellipsis">
      Sequential
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multitable-clustering" class="md-nav__link">
    <span class="md-ellipsis">
      Multitable Clustering
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#table-partitioning" class="md-nav__link">
    <span class="md-ellipsis">
      Table Partitioning
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b-tree-file-index" class="md-nav__link">
    <span class="md-ellipsis">
      B+ Tree File Index
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#data-dictionarysystem-catalog-storage" class="md-nav__link">
    <span class="md-ellipsis">
      Data Dictionary（System Catalog） Storage
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffer-management" class="md-nav__link">
    <span class="md-ellipsis">
      Buffer Management
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Buffer Management">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pin" class="md-nav__link">
    <span class="md-ellipsis">
      Pin
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lock" class="md-nav__link">
    <span class="md-ellipsis">
      Lock
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffer-replacement" class="md-nav__link">
    <span class="md-ellipsis">
      Buffer Replacement
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#force-output" class="md-nav__link">
    <span class="md-ellipsis">
      Force Output
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    <span class="md-ellipsis">
      十四章 索引
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十四章 索引">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    <span class="md-ellipsis">
      顺序/无序索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    <span class="md-ellipsis">
      稠密/稀疏索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#composite-search-key" class="md-nav__link">
    <span class="md-ellipsis">
      多值索引（Composite Search Key）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#b" class="md-nav__link">
    <span class="md-ellipsis">
      B+树索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    <span class="md-ellipsis">
      相关优化
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash" class="md-nav__link">
    <span class="md-ellipsis">
      Hash索引
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitmap" class="md-nav__link">
    <span class="md-ellipsis">
      Bitmap索引
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    <span class="md-ellipsis">
      十五章 查询操作
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十五章 查询操作">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#selection" class="md-nav__link">
    <span class="md-ellipsis">
      Selection
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Selection">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equations" class="md-nav__link">
    <span class="md-ellipsis">
      Equations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#comparison" class="md-nav__link">
    <span class="md-ellipsis">
      Comparison
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conjunction" class="md-nav__link">
    <span class="md-ellipsis">
      Conjunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#disjunction" class="md-nav__link">
    <span class="md-ellipsis">
      Disjunction
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bitmap-index-scan" class="md-nav__link">
    <span class="md-ellipsis">
      Bitmap Index Scan
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#external-sort" class="md-nav__link">
    <span class="md-ellipsis">
      External Sort
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join_1" class="md-nav__link">
    <span class="md-ellipsis">
      Join
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Join">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#block-nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Block Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#indexed-nested-loop-join" class="md-nav__link">
    <span class="md-ellipsis">
      Indexed Nested-Loop Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sort-merge-join" class="md-nav__link">
    <span class="md-ellipsis">
      Sort-Merge Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hash-join" class="md-nav__link">
    <span class="md-ellipsis">
      Hash Join
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#complex-join" class="md-nav__link">
    <span class="md-ellipsis">
      Complex Join
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-operations" class="md-nav__link">
    <span class="md-ellipsis">
      Other Operations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#expression" class="md-nav__link">
    <span class="md-ellipsis">
      Expression
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Expression">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#materialization" class="md-nav__link">
    <span class="md-ellipsis">
      Materialization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pipeline" class="md-nav__link">
    <span class="md-ellipsis">
      Pipeline
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    <span class="md-ellipsis">
      十六章 查询优化
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十六章 查询优化">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#equivalence-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Equivalence Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#statistical-cost-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Statistical Cost Estimation
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Statistical Cost Estimation">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#histogram" class="md-nav__link">
    <span class="md-ellipsis">
      Histogram
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selection-size-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Selection Size Estimation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#join-size-estimation" class="md-nav__link">
    <span class="md-ellipsis">
      Join Size Estimation
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-estimations" class="md-nav__link">
    <span class="md-ellipsis">
      Other Estimations
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#estimation-of-distinct-value" class="md-nav__link">
    <span class="md-ellipsis">
      Estimation of Distinct Value
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cost-base-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Cost Base Optimize
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Cost Base Optimize">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#join-order-selection" class="md-nav__link">
    <span class="md-ellipsis">
      Join-Order Selection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cost-based-optimization-with-equivalence-rules" class="md-nav__link">
    <span class="md-ellipsis">
      Cost Based Optimization with Equivalence Rules
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#heuristic-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Heuristic Optimize
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nested-subqueries-optimize" class="md-nav__link">
    <span class="md-ellipsis">
      Nested Subqueries Optimize
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#materialized-view" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Materialized View">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#materialized-view-maintenance" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View Maintenance
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#query-optimization" class="md-nav__link">
    <span class="md-ellipsis">
      Query Optimization
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#materialized-view-selection" class="md-nav__link">
    <span class="md-ellipsis">
      Materialized View Selection
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#transaction" class="md-nav__link">
    <span class="md-ellipsis">
      十七章 Transaction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十七章 Transaction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#acid" class="md-nav__link">
    <span class="md-ellipsis">
      ACID 原则
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    <span class="md-ellipsis">
      并发控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="并发控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#serializability" class="md-nav__link">
    <span class="md-ellipsis">
      Serializability
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recoverable-schedule" class="md-nav__link">
    <span class="md-ellipsis">
      Recoverable Schedule
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#trade-off" class="md-nav__link">
    <span class="md-ellipsis">
      Trade Off
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    <span class="md-ellipsis">
      十八章 并发控制
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十八章 并发控制">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#lock-based-protocols" class="md-nav__link">
    <span class="md-ellipsis">
      Lock-Based Protocols
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Lock-Based Protocols">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    <span class="md-ellipsis">
      内部实现
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    <span class="md-ellipsis">
      常见问题
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#two-phase-lock-protocols" class="md-nav__link">
    <span class="md-ellipsis">
      Two-phase Lock Protocols
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tree-based-protocol-in-graph-based-protocol" class="md-nav__link">
    <span class="md-ellipsis">
      Tree-Based Protocol (\(\in\) Graph-Based Protocol)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#handling-deadlock" class="md-nav__link">
    <span class="md-ellipsis">
      Handling Deadlock
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Handling Deadlock">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    <span class="md-ellipsis">
      死锁预防
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    <span class="md-ellipsis">
      检测死锁
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_39" class="md-nav__link">
    <span class="md-ellipsis">
      死锁恢复
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multiple-granularity" class="md-nav__link">
    <span class="md-ellipsis">
      Multiple Granularity
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#other-operations_1" class="md-nav__link">
    <span class="md-ellipsis">
      Other Operations
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Other Operations">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#insertdelete" class="md-nav__link">
    <span class="md-ellipsis">
      Insert/Delete
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#predicate-reads" class="md-nav__link">
    <span class="md-ellipsis">
      Predicate Reads
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#log-based-recovery" class="md-nav__link">
    <span class="md-ellipsis">
      十九章 错误恢复（Log-Based Recovery）
    </span>
  </a>
  
    <nav class="md-nav" aria-label="十九章 错误恢复（Log-Based Recovery）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_40" class="md-nav__link">
    <span class="md-ellipsis">
      错误类型
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_41" class="md-nav__link">
    <span class="md-ellipsis">
      日志
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_42" class="md-nav__link">
    <span class="md-ellipsis">
      日志恢复
    </span>
  </a>
  
    <nav class="md-nav" aria-label="日志恢复">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#check-point" class="md-nav__link">
    <span class="md-ellipsis">
      Check Point
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#undoredo" class="md-nav__link">
    <span class="md-ellipsis">
      Undo/Redo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#buffers" class="md-nav__link">
    <span class="md-ellipsis">
      Buffers
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_43" class="md-nav__link">
    <span class="md-ellipsis">
      磁盘恢复
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#undo" class="md-nav__link">
    <span class="md-ellipsis">
      锁的提前释放和逻辑Undo
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ARIES">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#physiological-redoredo" class="md-nav__link">
    <span class="md-ellipsis">
      Physiological Redo（物理逻辑Redo）
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries-data-structure" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES Data Structure
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#aries_1" class="md-nav__link">
    <span class="md-ellipsis">
      ARIES具体步骤
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_44" class="md-nav__link">
    <span class="md-ellipsis">
      基于主存储的恢复
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="database">DataBase</h1>
<p><a href="https://github.com/yile-liu/ZJU_database_system">Fork Yile Liu</a></p>
<hr />
<h2 id="_1">第一章 引入</h2>
<h3 id="_2">数据库重要问题</h3>
<ul>
<li>
<p>data persistence: 数据持久化</p>
</li>
<li>
<p>convenience in accessing data: 方便的数据访问</p>
</li>
<li>
<p>data integrity: 数据完整性</p>
</li>
<li>
<p>concurrency control for multiple user: 多用户并发控制</p>
</li>
<li>
<p>failure recovery: 失败恢复</p>
</li>
<li>
<p>security control: 安全控制</p>
</li>
</ul>
<h3 id="_3">系统结构</h3>
<ul>
<li>
<p>Physical Level: 数据在磁盘上的存储方式</p>
</li>
<li>
<p>Logical Level: 数据在用户看来的存储方式</p>
</li>
<li>
<p>View Level: 用户看到的数据</p>
</li>
</ul>
<h3 id="_4">数据库语言</h3>
<ul>
<li>
<p><strong>DDL</strong> (Data Definition Language)</p>
<ul>
<li>
<p>数据定义语言，定义数据库的结构</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-0-1" name="__codelineno-0-1" href="#__codelineno-0-1"></a><span class="w">    </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">student</span><span class="p">(</span>
<a id="__codelineno-0-2" name="__codelineno-0-2" href="#__codelineno-0-2"></a><span class="w">        </span><span class="n">name</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<a id="__codelineno-0-3" name="__codelineno-0-3" href="#__codelineno-0-3"></a><span class="w">        </span><span class="p">...</span>
<a id="__codelineno-0-4" name="__codelineno-0-4" href="#__codelineno-0-4"></a><span class="w">        </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
<a id="__codelineno-0-5" name="__codelineno-0-5" href="#__codelineno-0-5"></a><span class="w">        </span><span class="k">foreign</span><span class="w"> </span><span class="k">key</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="w"> </span>
<a id="__codelineno-0-6" name="__codelineno-0-6" href="#__codelineno-0-6"></a><span class="w">    </span><span class="p">);</span>
</code></pre></div>
</li>
<li>
<p>DDL interpreter: 用于解释DDL语句，将其转化为内部数据结构</p>
</li>
</ul>
</li>
<li>
<p><strong>DML</strong> (Data Manipulation Language)</p>
<ul>
<li>
<p>数据操作语言，对数据库中的数据进行操作</p>
</li>
<li>
<p>Procedural DML: 通过过程化语言进行操作</p>
</li>
<li>
<p>Declarative DML(nonprocedural): 通过声明式语言进行操作(例如SQL，更加常见)</p>
</li>
<li>
<p>DML compiler: 用于解释DML语句</p>
</li>
</ul>
</li>
<li>
<p><strong>Query Processor</strong></p>
<ul>
<li>query -&gt; parse and translate -&gt; relational-algebra -&gt; optimizer -&gt; query plan -&gt; execute plan</li>
</ul>
</li>
<li>
<p><strong>transaction management</strong></p>
<ul>
<li>
<p>事务管理，保证数据库的一致性</p>
</li>
<li>
<p>事务：一系列操作，要么全部执行，要么全部不执行</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="_5">第二章 数据库概念</h2>
<h3 id="_6">概念引入</h3>
<h4 id="table">Table</h4>
<p>可以类比excel，数据库以表的形式组织数据。表中的一列是某一类数据，一行是某一个事物具有的多类数据的集合。一张表是多个集合组成的大集合。</p>
<p>注意根据集合不能有相同元素的要求，一张表中不能出现数据相同的两行，也不能出现意义相同的两列。数据库课程一般不考虑空集。</p>
<h4 id="relation">Relation</h4>
<p>表的一行是某一个事物具有的多类属性，反过来说多类属性由某个事物关联起来。从这个意义上，一个Relation一般指代一张Table。</p>
<p>Relation又可以分为两个部分：</p>
<ul>
<li>
<p><strong>Relation Schema</strong></p>
<p>Relation Schema指一张表的逻辑设计，包括Table的名字，其中有哪些Attribute，每个Attribute各自的Domain等。Relation Schema不关心表中具体的数据，只关心整体设计。</p>
<p>R = (A_1, A_2, A_3, ... A_n)</p>
<p>例如：Student(Student_ID, Name, Phone_Number), in which Student_ID supposed to be ......这是一个Relation Schema。</p>
</li>
<li>
<p><strong>Relation Instance</strong></p>
<p>Relation Instance是一张表中具体某几个事物（某几行）的集合。出于集合的定义，Relation Instance是可拆分的，一个Instance从中的某几行组成集合是另一个新的Instance。</p>
<p>r(R) = {(t_1), (t_2), ... (t_n)}</p>
<p>例如：{(3200102708, Liu Siri, 13588089548), (3200102706, Su Houxian, null)}这是一个Relation Instance。</p>
<p><strong>关于元组</strong>：</p>
<ul>
<li>
<p>Tuple</p>
<p>直译为元组，指某个表中的一个事物，或者说一行。</p>
</li>
<li>
<p>Attribute</p>
<p>直译为属性，指某个表中的某一类数据，或者说一列。</p>
</li>
<li>
<p>Domain</p>
<p>某个Attribute的取值范围。</p>
</li>
<li>
<p><em>Unordered Set</em></p>
<p>表中的行是无序的，即表中的行的顺序不影响表的定义。</p>
</li>
</ul>
</li>
<li>
<p><strong>Atomic</strong></p>
<p>我们要求数据库中任意关系r，其Attribute的Domain必须是Atomic的。某个Domain是Atomic的指其中存储的数据已经是最小单元，不能进一步拆分。</p>
<p>例如：对于Attribue(Phone_Number)，如果允许多个电话号的集合同时存储在该列某行中，那么这个Attribute就不满足Atomic，于是这张表也不满足数据库的设计规范，因为一般认为这个集合可以进一步拆分成一个个电话号。</p>
<p>但是注意，你既可以认为单个电话号为不能继续拆分的最小单位，这时它Atomic；也可以认为电话号又包括了国家编码、区号、分机号等等，不满足Atomic。</p>
<p><strong>因此Atomic是一个相对的概念</strong>，“能不能继续拆分”取决于设计数据库的具体要求与你看待数据的方式。</p>
</li>
</ul>
<h4 id="key">Key</h4>
<p>Key是某一个relation中某几个attribute的集合。它的每一个子集也都是不同的Key。</p>
<ul>
<li>
<p>Superkey</p>
<p>如果在某relation instance中根据一个key能够单独确定一个tuple，它是Superkey</p>
<p>因此，superkey 可以很大，如 <em>整个元组的所有属性就是一个superkey</em></p>
</li>
<li>
<p>Candidate Key</p>
<p>如果一个Superkey，去掉任意一个attribute后不再是Superkey，他就是Candidate Key</p>
<p>就相当于是<strong>“最小”的Superkey</strong>    </p>
</li>
<li>
<p>Primary Key（默认not null）</p>
<p>使用任意Candidate Key都可以方便的查找relation中的某个tuple，但是为了同一操作、规范接口，设计者应该为每个relation在Candidates中选出一个作为Primary Key (a.k.a. Primary Key Constraint)。</p>
<p>Primary Key是relation的固有属性而不仅是attribute的集合，地位发生了变化。</p>
</li>
<li>
<p>Foreign Key Constraint</p>
<p>A是关系<span class="arithmatex">\(r_{1}\)</span>的一个key，（B是关系<span class="arithmatex">\(r_{2}\)</span>的Primary Key，）如果A中每个tuple都在B中都存在，就称</p>
<p>A is a <strong>foreign key</strong> from <span class="arithmatex">\(r_{1}\)</span> referencing <span class="arithmatex">\(r_{2}\)</span></p>
<p><span class="arithmatex">\(r_{1}\)</span> is the <strong>referencing relation</strong> of this foreign-key constraint and <span class="arithmatex">\(r_{2}\)</span> Is the <strong>referenced relation</strong></p>
<p><code>foreign key A referencing r2(B1)</code></p>
</li>
</ul>
<h4 id="schema-diagram">Schema Diagram</h4>
<p>规定某个relation的Primary Key由下划线标出；有向箭头表示Foreign Key Constraint，从referencing relation指向referenced relation。</p>
<h3 id="_7">关系代数</h3>
<h4 id="_8">基础操作</h4>
<ul>
<li>
<p>And Or Not(∧ ∨ ¬)</p>
</li>
<li>
<p>Select</p>
<p><span class="arithmatex">\(\sigma_{selection\  predicate}(relation)\)</span>：从relation中选出满足selection predicate的tuple组成一个新的relation。即选行。</p>
</li>
<li>
<p>Project</p>
<p><span class="arithmatex">\(\Pi_{A1,A2...}(relation)\)</span>：从relation中选出名称为A1、A2……的attribute组成一个新的relation,即选列。</p>
<p><strong>注意这是集合操作，因此会自动去重</strong></p>
</li>
<li>
<p>Union（<span class="arithmatex">\(\cup\)</span>）</p>
<ul>
<li>待合并的两张表应该应该相同的属性元组（即属性完全相同）</li>
</ul>
</li>
<li>
<p>Intersection（<span class="arithmatex">\(\cap\)</span>）</p>
<ul>
<li>待合并的两张表应该应该相同的属性元组（即属性完全相同）</li>
</ul>
</li>
<li>
<p>Set Difference（-）</p>
<ul>
<li>待合并的两张表应该应该相同的属性元组（即属性完全相同）</li>
</ul>
</li>
<li>
<p>Cartesian-Product（<span class="arithmatex">\(\times\)</span>）</p>
<ul>
<li>
<p>开销很大，可以想办法先用选择条件降低表大小再做积（不过应该不用强求）</p>
</li>
<li>
<p>两个表做笛卡尔积，会获得 N * M 行</p>
</li>
</ul>
</li>
<li>
<p><strong>Join</strong> （后面章节重点）</p>
<ul>
<li>
<p><span class="arithmatex">\(r\bowtie_{predicate}s=\sigma_{predicate}(r\times s)\)</span></p>
</li>
<li>
<p>Inner Join: <span class="arithmatex">\(r \bowtie s\)</span></p>
</li>
<li>
<p>Outer Join</p>
<ul>
<li>
<p>Left Outer Join: <span class="arithmatex">\(r\ ⟕\ s\)</span></p>
</li>
<li>
<p>Right Outer Join: <span class="arithmatex">\(r\ ⟖\ s\)</span></p>
</li>
<li>
<p>Full Outer Join: <span class="arithmatex">\(r\ ⟗\ s\)</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>Rename</em></p>
<ul>
<li>
<p><span class="arithmatex">\(\rho_{x(A_{1},A_{2}...)}(E)\)</span></p>
<p>将名为E的表重命名为x，并将其每一列重命名为A1、A2……</p>
</li>
<li>
<p>下标<span class="arithmatex">\((A_{1},A_{2}...)\)</span>不是必须的，不写这一部分表示只改表名不改列名。</p>
</li>
</ul>
</li>
<li>
<p><em>Assignment</em></p>
<ul>
<li>
<p><span class="arithmatex">\(d\leftarrow expression\)</span></p>
<p>将表达式的结果存放在临时“变量”d中，以便后续复用。这个操作一般用于简化公式和增强可读性。</p>
</li>
<li>
<p>注意数据库所有的返回值都是<strong>表</strong>，包括代数操作或者单指操作等。</p>
</li>
</ul>
</li>
<li>
<p><em>Division</em></p>
<ul>
<li>let <span class="arithmatex">\(r(ID,course.ID)\)</span> and <span class="arithmatex">\(s(course.ID)\)</span>,  then <span class="arithmatex">\(r\div s\)</span> gives us ID who have taken all courses in the relation <span class="arithmatex">\(s\)</span>.</li>
</ul>
</li>
<li>
<p>代数操作</p>
<ul>
<li>常见的代数操作有avg, min, max, sum, count等</li>
</ul>
</li>
</ul>
<hr />
<h2 id="sql">第三章 SQL基础</h2>
<h3 id="sql_1">SQL数据类型</h3>
<p><strong>char(n)</strong>: 定长为n的字符串</p>
<p><strong>varchar(n)</strong>: variable-lenth char 最大长度为n的可变长字符串</p>
<p><strong>int/smallint</strong>: 整数型，允许的数据范围由库和计算机架构决定。smallint占据的空间与可表示的范围都小于int。</p>
<p><strong>numeric(p, d)</strong>: 十进制表示，总共有p位，其中小数点后有d位。例如对numeric(3, 1)，10.5、01.0是合法的，1.05、105、1都是不合法的。</p>
<p><strong>real/double precision</strong>: 单精度和双精度浮点，大致对应C语言的float/double。允许的数据范围由库和计算机架构决定。</p>
<p><strong>float(n)</strong>: 至少有n个数字的浮点数。注意区别SQL的float与常见编程语言的float。</p>
<p><strong>NULL</strong></p>
<ul>
<li>
<p>代表未知，和 0 不相同</p>
</li>
<li>
<p><strong>特殊运算规则</strong></p>
<ul>
<li>
<p>and 有0为假</p>
</li>
<li>
<p>or 有1为真</p>
</li>
<li>
<p>比较 / 算术等结果为unknown</p>
</li>
<li>
<p>not unknown = unknown</p>
</li>
<li>
<p>where 中认为 unknown 为 false</p>
</li>
<li>
<p>筛选distinct时，null = null</p>
</li>
<li>
<p>NULL值不参与对列的代数函数，但是全NULL的tuple会被count(*)计数（直接数行数）。没有非NULL元素时代数操作返回NULL，count( )返回0。</p>
</li>
</ul>
</li>
</ul>
<p><strong>注意：以上是教科书中的内容，其中char/varchar/int基本全世界通用，但是其他的数据类型在不同DBMS中语法及用法可能各有不同。</strong></p>
<hr />
<h3 id="sql_2">SQL语句</h3>
<p>所有SQL语句以及<strong>表名、列名</strong>等标识符都是大小写不敏感的</p>
<p>但是表的<strong>内容</strong>，例如字符串等，大小写敏感。</p>
<p>以下只记录易错点，不涵盖所有语法。</p>
<h4 id="updates-to-tables">Updates to tables</h4>
<ul>
<li>
<p><code>drop table r;</code></p>
</li>
<li>
<p><code>alter table r add column_name data_type;</code></p>
</li>
<li>
<p><code>alter table r drop column_name;</code></p>
</li>
</ul>
<h4 id="select">select</h4>
<p>select可以细分为select all与select distinct，区别是是否为结果去重，select不使用后缀时默认为select all</p>
<p>select选择的内容可以是表达式，例如select salary/1000 from teacher; 返回的是salary/1000的结果。</p>
<p>from子句可以包含多个表，用逗号分隔，例如from r1, r2, r3...，这样select的结果就是这些表的笛卡尔积。</p>
<p>后面一般有where子句，用于筛选表中的内容。</p>
<p><em>因此select可以没有from子句，一般用于展示数据或者赋值并展示结果，例如select 12345/5; 单纯打印这个表达式的结果数字</em></p>
<p>select结果可以使用order by ATTRIBUTE_NAME (desc/asc)子句排序，desc/asc表示按照降/升序，不写默认为asc。</p>
<p>order by后面可以跟多个attribute，以逗号分隔，靠前的优先。</p>
<p><em>select 'k' from ---&gt;N行 一列'k', 属性'k'</em></p>
<h4 id="as">as</h4>
<p>as可以为同一个对象赋两个别名以实现自我对比，但是别名的作用域仅限于单条语句，实际名称并不会被更改.</p>
<h4 id="string">string</h4>
<p>SQL 用一对单引号表示字符串，若要在字符串中使用单引号，可以用两个单引号表示一个单引号。</p>
<p>like是模糊搜索的关键字，可以用 % 表示任意多个字符，用 _ 表示任意一个字符</p>
<p>需要字符串查找内容本身包含特殊字符的，可以用逃逸符号+转义字符，如获得'%' <code>'\%' escape '\'</code></p>
<p>字符串内容匹配默认区分大小写。</p>
<h4 id="set">set</h4>
<ul>
<li>
<p>set operations</p>
<ul>
<li>
<p><code>union / intersect / except</code> 又有all和distinct两个版本，区别是结果是否去重</p>
</li>
<li>
<p><strong>但是他们默认作为集合操作是去重的</strong>，这与select不同。</p>
</li>
</ul>
</li>
<li>
<p>set membership</p>
<ul>
<li><code>(not) in</code></li>
</ul>
</li>
<li>
<p>set comparison</p>
<ul>
<li>
<p><code>some / all</code></p>
</li>
<li>
<p>( = some) == (in) </p>
</li>
<li>
<p>( != some) != (not in)</p>
</li>
<li>
<p>(!= all) == (not in)</p>
</li>
<li>
<p>( = all) != (in)</p>
</li>
</ul>
</li>
<li>
<p>set empty test</p>
<ul>
<li><code>(not) exists</code></li>
</ul>
</li>
<li>
<p>set unique test</p>
<ul>
<li><code>unique</code> to check if duplicates exist</li>
</ul>
</li>
</ul>
<h4 id="aggregate-functions">aggregate functions</h4>
<p><code>avg, count, min, max, sum</code></p>
<p>聚集函数，顾名思义，能把同一列不同值聚集到一起处理为一个值</p>
<p><strong>注意，where语句中不能使用聚合函数，只有select后或having语句中可以使用</strong></p>
<h4 id="group-by">group by</h4>
<p>配合各类代数操作</p>
<p>group by先于select进行，创建一个仅包含代数<strong>操作列</strong>与<strong>group by列</strong>的临时表，select操作在这个临时表中进行。这带来两个特性：</p>
<ul>
<li>
<p>select...group by...可以在多个列名和列数不完全相同的表中进行，只要共有用于代数操作和group by的列就可以了。例如下面的表r1、r2……只要共有A1、A2（用于group by）和A3（用于sum）即可，其余列无所谓。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a><span class="k">select</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="nf">sum</span><span class="p">(</span><span class="n">A3</span><span class="p">)</span>
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a><span class="k">from</span><span class="w"> </span><span class="n">r1</span><span class="p">,</span><span class="w"> </span><span class="n">r2</span><span class="p">,</span><span class="w"> </span><span class="n">r3</span><span class="p">...</span>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a><span class="k">where</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">A1</span><span class="p">,</span><span class="w"> </span><span class="n">A2</span>
</code></pre></div>
</li>
<li>
<p>同时select代数操作和其他的列时，其他列必须同时放在group by里面，因为不能选择临时表中没有的列，否则得不到理想中想要的结果（不一定报错）。下面是两个错误的例子，ID不能被选择：</p>
<p><strong>即group by之后，每个group只能输出一行数据</strong></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-2-1" name="__codelineno-2-1" href="#__codelineno-2-1"></a><span class="k">select</span><span class="w"> </span><span class="n">dept_name</span><span class="p">,</span><span class="w"> </span><span class="n">ID</span><span class="p">,</span><span class="w"> </span><span class="k">avg</span><span class="w"> </span><span class="p">(</span><span class="n">salary</span><span class="p">)</span>
<a id="__codelineno-2-2" name="__codelineno-2-2" href="#__codelineno-2-2"></a><span class="k">from</span><span class="w"> </span><span class="n">instructor</span>
<a id="__codelineno-2-3" name="__codelineno-2-3" href="#__codelineno-2-3"></a><span class="k">group</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">dept_name</span><span class="p">;</span>
<a id="__codelineno-2-4" name="__codelineno-2-4" href="#__codelineno-2-4"></a>
<a id="__codelineno-2-5" name="__codelineno-2-5" href="#__codelineno-2-5"></a><span class="k">select</span><span class="w"> </span><span class="n">ID</span><span class="p">,</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">salary</span><span class="p">)</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">instructor</span><span class="p">;</span>
</code></pre></div>
</li>
</ul>
<h4 id="where-having">where / having</h4>
<p><strong>where在group by之前进行，不满足条件的tuble不会参与group by进入临时表</strong></p>
<p><strong>having在group by之后进行，在临时表中筛选（因此同样只有group by之后的数据栏），只返回满足的tuble</strong></p>
<p>因此引申出exists只能跟where；代数操作做条件只能跟having；同样的语句在where和having之后效果不一定相同。</p>
<h4 id="with">with</h4>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="k">with</span><span class="w"> </span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="n">temp_table_name1</span><span class="p">(</span><span class="n">attribute_name1</span><span class="p">,</span><span class="w"> </span><span class="n">attibute_name2</span><span class="p">...)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(),</span>
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a><span class="n">temp_table_name2</span><span class="p">(</span><span class="n">attribute_name1</span><span class="p">,</span><span class="w"> </span><span class="n">attibute_name2</span><span class="p">...)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(),</span>
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="p">...</span>
</code></pre></div>
<p>建立一个作用域为一条语句的临时的表用于简化逻辑表达式增加可读性。
相当于关系代数中的Assignment。select可以不出现。</p>
<h4 id="delete">delete</h4>
<p><code>delete from table_name where ()</code></p>
<h4 id="insert">insert</h4>
<p><code>insert into table_name values(...)</code></p>
<p><code>insert into table_name(attributes...) values(...)</code></p>
<p><em>values 也可替换成嵌套子查询</em></p>
<h4 id="update">update</h4>
<ul>
<li>
<p><code>update table_name set attribute = () where ()</code></p>
</li>
<li>
<p>有时操作会影响后续的判断，导致非常麻烦的拓扑序处理，因此复杂时可以使用case条件判断</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-4-1" name="__codelineno-4-1" href="#__codelineno-4-1"></a><span class="k">set</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">case</span>
<a id="__codelineno-4-2" name="__codelineno-4-2" href="#__codelineno-4-2"></a><span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="n">condition1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">value1</span>
<a id="__codelineno-4-3" name="__codelineno-4-3" href="#__codelineno-4-3"></a><span class="w">    </span><span class="k">when</span><span class="w"> </span><span class="n">condition2</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">value2</span>
<a id="__codelineno-4-4" name="__codelineno-4-4" href="#__codelineno-4-4"></a><span class="w">    </span><span class="p">...</span>
<a id="__codelineno-4-5" name="__codelineno-4-5" href="#__codelineno-4-5"></a><span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="n">value2</span>
<a id="__codelineno-4-6" name="__codelineno-4-6" href="#__codelineno-4-6"></a><span class="k">end</span>
</code></pre></div>
</li>
</ul>
<hr />
<h2 id="sql_3">第四章 SQL进阶</h2>
<h3 id="join">Join</h3>
<p>Join语句的基本功能是将两张表中的tuple按一定规则进行匹配，将他们相同的列拼起来，不同的列全部保留，合成一个大tuple。</p>
<p>它的控制符可以分为两类：</p>
<ul>
<li>
<p>Join Conditions（控制哪一些列或条件用于匹配两张表中的tuple）</p>
<ul>
<li>
<p><strong>natural</strong>：tuple所有同名列的值相等（默认），但是有<strong>表结构未知错误合并</strong>的风险</p>
<ul>
<li>
<p>natural 会合并同名列，且using也是相当于默认为natural（natural left join，natural在前)</p>
</li>
<li>
<p>如果没有同名列，会默认输出笛卡尔积</p>
</li>
</ul>
</li>
<li>
<p><strong>using (A1, A2...)</strong>：tuple同名列中指定的部分列的值相等</p>
</li>
<li>
<p><strong>on <code>&lt;predicate&gt;</code> </strong>：按照特定的规则匹配，不限于同名列</p>
</li>
</ul>
</li>
<li>
<p>Join Types（控制如何处理没有匹配对象的tuple）</p>
<ul>
<li>
<p>Inner Join：没有匹配对象则不返回（默认）</p>
</li>
<li>
<p>Left Outer Join：左侧表的tuple没有匹配对象，则为扩展的列填入NULL，一起返回（左边元素一定存在）</p>
</li>
<li>
<p>Right Outer Join：右侧表的tuple没有匹配对象，则为扩展的列填入NULL，一起返回（右边元素一定存在）</p>
</li>
<li>
<p>Full Outer Join：上面二者的并集</p>
</li>
</ul>
</li>
</ul>
<h3 id="view">View</h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="k">create</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="n">view_name</span><span class="p">(</span><span class="n">attributes</span><span class="p">...)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">()</span><span class="w"> </span>
</code></pre></div>
<p>view一般由于权限问题，遮掩部分数据用于查找以及接口，语法和with相同，作用也基本相同。唯一的区别是view一经定义则一直可用，而with的作用域仅有单条语句。</p>
<ul>
<li>
<p>view并不是实际存在的表，每次调用view时只是重复调用了筛选的条件。因此update table后，与之关联的view也会改变</p>
</li>
<li>
<p>我们一般不对view进行update，大部分SQL系统对update view有严格的限制。</p>
</li>
<li>
<p>部分SQL也支持materialize view，view此时是一张真实存在的表，这一般是为了用空间换时间，物化视图相关的表发生变化时，它自己也必须同时更新，以维持一般view的特性。</p>
</li>
<li>
<p>view dependecy: 可以嵌套定义，甚至自我递归定义？ </p>
</li>
</ul>
<h3 id="index">Index</h3>
<div class="highlight"><pre><span></span><code><a id="__codelineno-6-1" name="__codelineno-6-1" href="#__codelineno-6-1"></a><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">column1</span><span class="p">,</span><span class="w"> </span><span class="n">column2</span><span class="p">.....);</span><span class="o">//</span><span class="n">创建</span>
<a id="__codelineno-6-2" name="__codelineno-6-2" href="#__codelineno-6-2"></a><span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">table_name</span><span class="w"> </span><span class="k">DROP</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">index_name</span><span class="p">;</span><span class="o">//</span><span class="n">删除</span>
</code></pre></div>
<p>索引的原理类似于书的目录，要查找某个词不需要从头开始阅读书籍，可以从目录查到页码直接跳转，于是加快了查找的速度。其具体实现方式不需要深究。一个表可以创建多个索引，一个索引可以包含多个列（复合索引）。</p>
<p>但索引并不是尽善尽美，例如update之后，索引需要同步维护；同时索引是一种物理数据结构，有额外的空间与IO开销。不适当的索引设置反而会降低效率。</p>
<h3 id="integrity-constraint">Integrity Constraint</h3>
<p>完整性约束即对attribute内容的约束，不满足约束条件的tuple不能被插入。</p>
<p><em>对数据类型的约束既可以在定义表时规定，也可以后期通过domain关键字增删改</em></p>
<p>一般有4类约束方法：</p>
<ul>
<li>
<p><strong>not NULL</strong>：非空。</p>
</li>
<li>
<p><strong>Primary Key</strong>：构成主键的tuple不能重复。</p>
</li>
<li>
<p><strong>Check(Predicate)</strong>：自定义检查的条件，在数据表有改变时便会自动检查，例如 <code>CHECK (semester in ("spring", "autumn") )</code>。</p>
</li>
<li>
<p><strong>Foreign Key</strong> : 外键约束，（<em>原则上，可以不是</em>）自定的若干个attribute组成的tuple一定是table_name的主键之一，<strong>但是似乎指向的键一定要unique或primary</strong></p>
<p><code>foreign key (attribute_name) references table_name(attribute)</code></p>
</li>
</ul>
<p>约束被破坏时的处理方法：</p>
<ul>
<li>
<p>cascade: 级联，更新与删除等操作违反完整性约束，便会将影响的子数据一并处理掉（一般没有 insert cascade）</p>
<ul>
<li><em>还可以set null, set default等</em></li>
</ul>
</li>
<li>
<p>assertion: 断言，always satisfy</p>
</li>
<li>
<p>trigger：Events &amp; Actions</p>
<ul>
<li>有效但少用</li>
</ul>
</li>
</ul>
<h3 id="_9">特殊数据类型</h3>
<ul>
<li>
<p>时间相关</p>
<ul>
<li>
<p>date：日期</p>
</li>
<li>
<p>time：SQL自带时间相关的特殊数据类型</p>
</li>
<li>
<p>timestamp：date + time</p>
</li>
<li>
<p>interval：时间间隔</p>
</li>
</ul>
</li>
<li>
<p>大对象</p>
<ul>
<li>
<p>large number：对于尤其空间尤其巨大的值，传指针比直接传数据本身高效得多。在此理解即可。</p>
</li>
<li>
<p>large-object types</p>
<ul>
<li>
<p>blob: binary </p>
</li>
<li>
<p>clob: character</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>user-defined</p>
<ul>
<li>e.g. <code>create type dollar as numeric(10, 2);</code></li>
</ul>
</li>
<li>
<p>domain</p>
<ul>
<li>和 type类似，不过可以加上约束条件</li>
</ul>
</li>
</ul>
<h3 id="_10">权限</h3>
<ul>
<li>
<p>授予/收回权限的基本语法：</p>
<p>权限：<code>select, insert, update, delete, references, all privileges</code></p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-7-1" name="__codelineno-7-1" href="#__codelineno-7-1"></a><span class="k">grant</span><span class="w"> </span><span class="o">&lt;</span><span class="n">priviledge</span><span class="w"> </span><span class="k">list</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="k">name</span><span class="o">&gt;</span><span class="w"> </span>
<a id="__codelineno-7-2" name="__codelineno-7-2" href="#__codelineno-7-2"></a><span class="k">on</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation</span><span class="w"> </span><span class="k">name</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="k">name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="o">&lt;</span><span class="k">user</span><span class="w"> </span><span class="k">list</span><span class="o">&gt;</span><span class="p">;</span><span class="o">//</span><span class="n">授予</span>
<a id="__codelineno-7-3" name="__codelineno-7-3" href="#__codelineno-7-3"></a>
<a id="__codelineno-7-4" name="__codelineno-7-4" href="#__codelineno-7-4"></a><span class="k">revoke</span><span class="w"> </span><span class="o">&lt;</span><span class="n">priviledge</span><span class="w"> </span><span class="k">list</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="k">name</span><span class="o">&gt;</span><span class="w"> </span>
<a id="__codelineno-7-5" name="__codelineno-7-5" href="#__codelineno-7-5"></a><span class="k">on</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation</span><span class="w"> </span><span class="k">name</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="k">view</span><span class="w"> </span><span class="k">name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="o">&lt;</span><span class="k">user</span><span class="w"> </span><span class="k">list</span><span class="o">&gt;</span><span class="p">;</span><span class="o">//</span><span class="n">收回</span>
</code></pre></div>
</li>
<li>
<p>权限可以来自多个上级用户，相互可以重叠，例如有两者都为第三方授予了读取权限，此时即使有一方撤回了权限，第三方仍然可以正常读取。</p>
</li>
<li>
<p>权限可以级联下放，例如A为B授予了某些权限，B可以继续向其他人授予不高于他自己的权限。当A撤回对B的权限时，B下放给他人的权限也会同时被收回。</p>
</li>
<li>
<p>权限的基本单位是relation，需要授予某个数据库内所有relation的权限时可以使用 DB_name.*</p>
</li>
<li>
<p>多次授权，一次只能收一个</p>
</li>
<li>
<p>public收回，所有非特殊指明的人的权限都被收回</p>
</li>
<li>
<p><em>视图上的权限效果类似</em>，但是视图的权限不能获得对基表的权限</p>
</li>
<li>
<p><strong>role</strong></p>
<ul>
<li>
<p>有多个同类用户需要做统一的权限调整时，列出 <code>&lt;user list&gt;</code> 的使用方式显然不便，此时就需要role。</p>
</li>
<li>
<p>role是权限组成的集合，可以像面向一个用户一样赋予role各种权限，然后像赋予单个权限一样将role赋予用户。修改某个role对应的权限集合时，所有被赋予这个role身份的用户权限都会同时被修改。</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="k">create</span><span class="w"> </span><span class="k">role</span><span class="w"> </span><span class="n">role_name</span><span class="p">;</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="k">grant</span><span class="w"> </span><span class="o">&lt;</span><span class="n">priviledge</span><span class="w"> </span><span class="k">list</span><span class="o">&gt;</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="o">&lt;</span><span class="n">relation</span><span class="w"> </span><span class="k">name</span><span class="o">&gt;</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">role_name</span><span class="p">;</span>
<a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="k">grant</span><span class="w"> </span><span class="n">role_name</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="o">&lt;</span><span class="k">user</span><span class="w"> </span><span class="k">list</span><span class="o">&gt;</span><span class="p">;</span>
</code></pre></div>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="sql_4">第五章 高级SQL</h2>
<h3 id="sql-injection">SQL Injection</h3>
<p>SQL用户端常常需要将用户的输入拼接为完整的sql语句。借助用户端输入框直接输入未预期的sql指令，又由于字符串拼接的缘故这条语句能够被后台执行，这称为sql注入。</p>
<p>避免sql注入的办法是，不要将用户的输入直接作为数据库语句，而是套用一定的模板。</p>
<h3 id="stored-procedure">Stored Procedure</h3>
<p>通过用户界面的前后端构建、传递、执行、回传sql代码带来大量的开销，所以现代sql都支持Stored Procedure。你可以将它理解为一种内建的小型编程语言，支持if-else、for、while等简单编程逻辑，用于构造执行一些sql语句，最终返回结果。sql还支持function，作用与之基本类似。</p>
<p>因为它们是内建的，且大多采用类似C语言的编译执行方式，性能往往远高于在用户端拼接字符串构建并执行sql语句。</p>
<p>Stored Procedure与function中还可以创建cursor，以完成一些复杂的数据库操作。</p>
<p>例如：</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-9-1" name="__codelineno-9-1" href="#__codelineno-9-1"></a><span class="k">create</span><span class="w"> </span><span class="k">procedure</span>
<a id="__codelineno-9-2" name="__codelineno-9-2" href="#__codelineno-9-2"></a><span class="n">dept_count_proc</span><span class="w"> </span><span class="p">(</span><span class="k">in</span><span class="w"> </span><span class="n">dept_name</span><span class="w"> </span><span class="kt">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w"> </span><span class="k">out</span><span class="w"> </span><span class="n">d_count</span><span class="w"> </span><span class="kt">integer</span><span class="p">)</span>
<a id="__codelineno-9-3" name="__codelineno-9-3" href="#__codelineno-9-3"></a><span class="k">begin</span>
<a id="__codelineno-9-4" name="__codelineno-9-4" href="#__codelineno-9-4"></a><span class="k">select</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">d_count</span>
<a id="__codelineno-9-5" name="__codelineno-9-5" href="#__codelineno-9-5"></a><span class="k">from</span><span class="w"> </span><span class="n">instructor</span>
<a id="__codelineno-9-6" name="__codelineno-9-6" href="#__codelineno-9-6"></a><span class="k">where</span><span class="w"> </span><span class="n">instructor</span><span class="p">.</span><span class="n">dept_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dept_count_proc</span><span class="p">.</span><span class="n">dept_name</span>
<a id="__codelineno-9-7" name="__codelineno-9-7" href="#__codelineno-9-7"></a><span class="k">end</span>
<a id="__codelineno-9-8" name="__codelineno-9-8" href="#__codelineno-9-8"></a>
<a id="__codelineno-9-9" name="__codelineno-9-9" href="#__codelineno-9-9"></a><span class="k">declare</span><span class="w"> </span><span class="n">d_count</span><span class="w"> </span><span class="kt">integer</span><span class="p">;</span>
<a id="__codelineno-9-10" name="__codelineno-9-10" href="#__codelineno-9-10"></a><span class="k">call</span><span class="w"> </span><span class="n">dept_count_proc</span><span class="p">(</span><span class="s1">&#39;physics&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">d_count</span><span class="p">)</span>
</code></pre></div>
<h3 id="trigger">Trigger</h3>
<p>trigger是在满足某些条件后自动执行的sql，可以视为对数据库操作的监视或者说副作用。但是现代sql数据库流行的风格是不写trigger。</p>
<hr />
<h2 id="_11">第六章 数据库设计范式一</h2>
<p>本章主要介绍<strong>Entity-Relationship Model</strong>设计方式。不同于直接建表的做法，实际开发中我们更喜欢先用entity和relationship两类概念构建逻辑关系，再建表。</p>
<ul>
<li>
<p>Entity的每一行应该是一个实体，例如学生信息表，教师信息表。</p>
</li>
<li>
<p>Relation的每一行是多个实体间的某种关联，例如导师-学生关系表。</p>
</li>
</ul>
<h3 id="design-phases">Design phases</h3>
<ul>
<li>
<p>Initial phase: </p>
<ul>
<li>了解用户需求，确定数据库的目标</li>
</ul>
</li>
<li>
<p>Second phase: </p>
<ul>
<li>选择一个数据模型，设计数据库的概念结构</li>
</ul>
</li>
<li>
<p>Final phase: </p>
<ul>
<li>将概念结构转化为物理数据库模式，即建表</li>
</ul>
</li>
</ul>
<h3 id="design-alternatives">Design Alternatives</h3>
<ul>
<li>
<p>Redundancy</p>
<ul>
<li>数据冗余，即同一数据在多个地方重复出现。冗余数据的存在还会导致数据不一致，增加了数据的修改难度。</li>
</ul>
</li>
<li>
<p>Incompleteness</p>
<ul>
<li>系统不完整，导致某些功能无法实现。</li>
</ul>
</li>
</ul>
<h3 id="e-r-diagram">E-R Diagram</h3>
<ul>
<li>
<p>Entity</p>
<ul>
<li>
<p>由多个属性 Attribute 构成，属性的取值范围是 Domain</p>
</li>
<li>
<p><em>用实体集的外延 extension 表示实际的实体集合</em></p>
</li>
</ul>
</li>
<li>
<p>Attribute</p>
<ul>
<li>
<p><strong>复合</strong>：用缩进表达层级关系</p>
</li>
<li>
<p><strong>多值</strong>：（<strong>同一个属性可能有多个取值</strong>）用大括号表示</p>
</li>
<li>
<p><strong>派生</strong>：（<strong>可由其他属性推导出来</strong>）在后方加上括号抽象为函数</p>
</li>
</ul>
</li>
<li>
<p><strong>Entity-Relation</strong></p>
<blockquote>
<p>菱形表示，其中的文字是Relationship的名字，实体间的这种关联称为 <strong>参与联系集R（participation）</strong></p>
</blockquote>
<ul>
<li>
<p><strong>度 （Degree）</strong></p>
<blockquote>
<p>参与联系集的实体集的个数</p>
</blockquote>
<p>一般二元关系（binary）为主，有时有三元关系，再多元不常见</p>
</li>
<li>
<p><strong>额外属性(Discriptive Attribute)</strong></p>
<p>用<strong>方框 + 虚线</strong>表示</p>
<p><img alt="1712973598719" src="../image/Database/1712973598719.png" /></p>
</li>
<li>
<p><strong>Role</strong></p>
<blockquote>
<p>Role是连线或者箭头的标签。</p>
</blockquote>
<p>关系对应的Entities应该是唯一的，当关系与某个实体有多重逻辑联系 (Recursive) 时就需要为表达逻辑联系的线或箭头加上标签作为区分。</p>
<p><img alt="1712973929199" src="../image/Database/1712973929199.png" /></p>
</li>
<li>
<p><strong>Mapping Cardinality Constraints（映射基数约束）</strong></p>
<blockquote>
<p><strong>箭头表示“一”，直线表示“多”</strong></p>
<p><em>多关系时只允许至多一个箭头避免歧义</em></p>
</blockquote>
<ul>
<li>
<p>One-to-One：双向单直线箭头</p>
</li>
<li>
<p>One-to-Many：单向单直线箭头</p>
</li>
<li>
<p>Many-to-One：单向单直线箭头</p>
</li>
<li>
<p>Many-to-Many：单直线</p>
</li>
<li>
<p><strong>Participation Constraints</strong></p>
<ul>
<li>
<p>total participation</p>
<blockquote>
<p>每个实体至少参与一个关系</p>
</blockquote>
<p>用<strong>双直线+双直线框菱形</strong>表示</p>
</li>
<li>
<p>partial participation</p>
<p>单直线</p>
</li>
<li>
<p><strong>More accurate notation</strong></p>
<p>在单直线上使用数字标注 min...max</p>
<p><img alt="1712975619974" src="../image/Database/1712975619974.png" /></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Primary Key</strong></p>
<p><img alt="1712976256980" src="../image/Database/1712976256980.png" /></p>
</li>
<li>
<p><strong>Weak Entity Set</strong></p>
<blockquote>
<p>没有独立主键的Entity Set称为Weak，它一般是为了增加复用性</p>
</blockquote>
<ul>
<li>
<p>要求存在至少一个非Weak的<strong>Identifying Entity Set</strong>，通过一个<strong>完全参与的、一对多的</strong>关系，指认Weak Entity Set中的元素，这个关系就称为<strong>Identifying Relationship</strong>。</p>
</li>
<li>
<p>弱实体集的属性中与Identifying Relationship相关的属性称为<strong>Discriminator (partial key, 需要找一个强实体集的键一同构成主键)</strong></p>
<p>例如下图中section的主键为 (course_id, sec_id, semester, year) 。</p>
</li>
</ul>
<p><img alt="1712801478105" src="../image/Database/1712801478105.png" /></p>
<p>（<em>画E-R图时，虚实体用双线矩形，Discriminator用虚下划线，因为这是完全参与关系，用双线菱形标记关系，同时弱实体集一侧必须完全参与，所以用双线连接）</em></p>
</li>
<li>
<p><em>重复属性可以通过relation消除冗余</em></p>
<p><img alt="1712801814521" src="../image/Database/1712801814521.png" /></p>
</li>
</ul>
</li>
</ul>
<h4 id="e-r">特殊的E-R图</h4>
<ul>
<li>
<p>可以继承（Top-Down 特化 / Bottom-Up概化）</p>
<p><img alt="1712803636247" src="../image/Database/1712803636247.png" /></p>
<ul>
<li>
<p>Overlapping: 可重叠，即一个实体可以同时属于多个类别</p>
<p>（既是student，也是employee）</p>
</li>
<li>
<p>Disjoint：不相交，即一个实体只能属于一个类别</p>
<p>（只能是instructor或者secretary一种身份）</p>
</li>
</ul>
<p><strong>减少了冗余信息，但是增加了查询的复杂度（需要多表的笛卡尔积）</strong></p>
</li>
<li>
<p>可以聚合（Aggregation）</p>
<ul>
<li>将一个部分组合成一个整体，减少关系</li>
</ul>
</li>
</ul>
<p><em>两者一般都是为了减少冗余，但这都只是特殊逻辑关系的简化表达，并不常见，完全可以用常规的图代替</em></p>
<h3 id="reduction-to-relational-schemas">Reduction to Relational Schemas</h3>
<blockquote>
<p>根据E-R图建立数据库表结构，下面为推荐的实现方式，但是途径并不唯一。</p>
</blockquote>
<ul>
<li>
<p>Entity</p>
<ul>
<li>
<p>每个实体至少一张表</p>
</li>
<li>
<p>复合属性扁平化(选择级别最底层的)</p>
</li>
<li>
<p>多值属性单独建表，外键连回去</p>
</li>
</ul>
</li>
<li>
<p>Relationship</p>
<ul>
<li>
<p>带额外属性的Relationship单独建表</p>
</li>
<li>
<p>Many to Many必须单独建表</p>
</li>
<li>
<p>One to Many在Many侧加上One的主键，外键连回去</p>
</li>
<li>
<p>One to One任选一侧作为上面情况中的Many，同上</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="_12">第七章 数据库设计范式二</h2>
<p>如果说前一章节描述了如何建立一个表，那么本章将着重于如何根据函数依赖判断一张表的好坏，以及如何拆分一张表</p>
<h3 id="function-dependency">Function Dependency</h3>
<p>前面说到派生属性可以理解为函数，重点在于一对一的映射关系。相同的A一定有相同的B，记为<span class="arithmatex">\(A\rightarrow B\)</span>，A可以是B的一个主码，B可以视为A的派生属性，或者说B是A的函数依赖。</p>
<div class="arithmatex">\[tuple \ t_1, t_2 \in r, t_1[A] = t_2[A] \Rightarrow t_1[B] = t_2[B]\]</div>
<p>函数依赖可以根据集合关系分为下面3类：</p>
<ul>
<li>
<p><strong>完全函数依赖：</strong> A的任何一个真子集，或者说去掉任何一个列之后，对B不构成函数依赖，则称其为完全函数依赖，<strong>反之为部分函数依赖</strong>。</p>
</li>
<li>
<p><strong>传递函数依赖：</strong> 显然函数依赖具有传递性。通过传递间接得到的依赖称为传递依赖，例如closure中<span class="arithmatex">\(A\rightarrow B\)</span>。</p>
</li>
<li>
<p><strong>Trival平凡函数依赖：</strong>
    $$
    In\ general,\ A\rightarrow B\ is\ trival\ if\ B\subseteq A.\
    For\  example,\ (ID,\ name)\rightarrow name.
    $$</p>
</li>
</ul>
<p>对函数依赖组成的集合F，若一个relation满足F+中的所有依赖关系，称为：</p>
<ul>
<li>
<p>R(relation schema) <strong>holds on</strong> F</p>
</li>
<li>
<p>r(relation instance) <strong>satisfyies</strong> F</p>
</li>
</ul>
<p>对R holds on F，取R1为R的一个子集，F中左右两侧的属性都在R1中的函数依赖组成的集合称为F在R1上的投影。</p>
<h4 id="closure-of-function">Closure of Function</h4>
<p>给定一个由函数依赖组成的集合<span class="arithmatex">\(F\)</span>，它与它的所有推论组成的集合称为Closure of F，记为<span class="arithmatex">\(F^+\)</span>，例如：
$$
F(A\rightarrow B,\ B\rightarrow C)\
F^+(A\rightarrow B,\ B\rightarrow C,\ A\rightarrow C, AB \rightarrow C ...)
$$</p>
<p>找函数闭包一般是<strong>Armstrong's Axioms</strong>三条轮着套：(Sound(有效) &amp; Complete(完备))</p>
<p>书上算法：先用自反律和增补律添加新的依赖关系，再用传递律连接</p>
<p><img alt="1713407471264" src="../image/Database/1713407471264.png" /></p>
<p><img alt="1713410629655" src="../image/Database/1713410629655.png" /></p>
<h4 id="closure-of-attribute">Closure of Attribute</h4>
<p>给定一个由属性组成的集合<span class="arithmatex">\(A\)</span>，它由函数集<span class="arithmatex">\(F\)</span>中的依赖关系能够关联的属性组成的集合称为Closure of A under F，记为<span class="arithmatex">\(A^+\)</span></p>
<p>算法：每次枚举所有依赖关系，若满足左侧条件则将右侧属性加入闭包，直到闭包不再增大</p>
<p>属性的闭包的作用有：</p>
<ul>
<li>
<p>验证一组属性是否是superkey（它的闭包是否包含所有属性）</p>
</li>
<li>
<p>验证一组属性是否是candidate key（它的真子集的闭包是否包含所有属性）</p>
</li>
<li>
<p>验证函数依赖是否成立（依赖属性是否在被依赖属性的闭包中）</p>
</li>
<li>
<p>找函数的闭包（遍历属性的子集，挨个找闭包，闭包中多出来的属性就对原属性构成依赖）</p>
</li>
</ul>
<h4 id="canonical-cover">Canonical Cover</h4>
<ul>
<li>
<p><strong>Redundancy</strong></p>
<ul>
<li>
<p>在一个函数依赖集中，如果某一个依赖关系可以由其他依赖推得，那么他就是冗余的。</p>
</li>
<li>
<p>在单个依赖关系中，如果去掉一个属性（左右两侧至少要留下一个），仍然可以由其关系集中的其他依赖推得原式，那么就称这一个属性是冗余的。冗余的属性也可以用<strong>extraneous</strong>形容，直译为多余的。</p>
</li>
</ul>
<p><strong>需要注意这里逻辑蕴含 “<span class="arithmatex">\(\implies\)</span>” 的方向始终为弱<span class="arithmatex">\(\implies\)</span>强，左侧减少加强，右侧减少削弱</strong></p>
<p><strong>对应的检查就是删除掉假设的无关属性后，能否推出原来的函数依赖</strong></p>
<p><img alt="1714010926789" src="../image/Database/1714010926789.png" /></p>
<p><img alt="1714011493811" src="../image/Database/1714011493811.png" /></p>
</li>
<li>
<p><strong>正则覆盖</strong></p>
<blockquote>
<p>记为<span class="arithmatex">\(F_c\)</span>，指给定一组函数依赖F，去除所有冗余的函数依赖与属性后剩余的部分，相当于函数依赖F的化简集合</p>
<ul>
<li>
<p>不含冗余函数依赖</p>
</li>
<li>
<p>与原函数依赖集F等价，即<span class="arithmatex">\(F^+ \Leftrightarrow F_c^+\)</span></p>
</li>
<li>
<p>函数依赖的左侧属性不重复</p>
</li>
</ul>
</blockquote>
<p>求最小函数依赖集的步骤（<strong>正则覆盖可能不唯一</strong>）：</p>
<p><img alt="1714202283682" src="../image/Database/1714202283682.png" /></p>
</li>
</ul>
<h4 id="lossless-join-decomposition">Lossless(-join) Decomposition</h4>
<p>假设表R被拆分为若干个表R1、R2……Rn，当且仅当R1 nature join R2…… nature join Rn等于R时，称这个这个拆分操作是无损的。</p>
<ul>
<li>
<p>当分解为两个表时，证明无损拆分常用的一个<strong>充分非必要条件</strong>是：</p>
<p><strong>两张拆开的表取交集，交集是至少一张表的superkey，或者说可以通过F+中的函数依赖推得取交集之前的表</strong></p>
<div class="arithmatex">\[R1\cap R2 \rightarrow R1\ or\ R2\]</div>
</li>
<li>
<p>当分解为超过两个表时，使用判定表法：https://blog.csdn.net/weixin_42492218/article/details/106218720</p>
</li>
</ul>
<h4 id="dependancy-presevation">Dependancy Presevation</h4>
<p>在数据库更新时，我们希望依赖关系不会被破坏，即依赖保持</p>
<p>假设表R被拆分为若干个表R1、R2……Rn，函数依赖集F中左右两侧的属性都在R1、R2……中的子集为F1、F2……，称为F在R1、R2……上的投影(书中称为restriction)。</p>
<p>当<span class="arithmatex">\(F^+=F_1^+\cup F_2^+\cup...\)</span>时称这个拆分满足依赖保持(<strong>注意这仅仅是个充分条件</strong>)</p>
<p>同样的，由于函数闭包的计算代价过高，可以使用如下<strong>属性闭包</strong>来代替。相当于每次计算某条依赖限定在 <span class="arithmatex">\(F_i\)</span> 上的属性闭包，再合并起来，检查是否将这条依赖保持 </p>
<p><img alt="1714203819519" src="../image/Database/1714203819519.png" /></p>
<p><em>第三范式是满足依赖保持的最高范式, BC范式不能保证依赖保持</em></p>
<h3 id="_13">第三范式</h3>
<h4 id="_14">三大范式</h4>
<ul>
<li>第一范式</li>
</ul>
<p>要求每一个attribue的domain都是atomic的，不能继续分割（如CS-101即可继续分割成课程种类和标号，给更新带来麻烦），同时每一个relation都应该有primary key。</p>
<p>这是所有关系型数据库最基础的范式要求。</p>
<ul>
<li><em>第二范式（不重要）</em></li>
</ul>
<p>在第一范式的基础上，要求非主属性对所有candidate key不能有部分依赖，就像candidate key被浪费了一样。例如下面这个关系：</p>
<p>（学号，课名）是一个candidate key，但是姓名、系名都是对学号的函数依赖，即对候选键的部分依赖，所以上面这个数据库不满足第二范式，但是满足第一范式。</p>
<ul>
<li>第三范式</li>
</ul>
<p>在第二范式的基础上，要求非主属性对所有候选键不能有传递依赖。例如下面这个关系：</p>
<p><img alt="1713407061546" src="../image/Database/1713407061546.png" /></p>
<p>学号-&gt;系名-&gt;系主任是一个传递依赖关系，所以上面这个数据库不满足第三范式但是满足第二范式。</p>
<h4 id="_15">定义：</h4>
<p><img alt="1714204693174" src="../image/Database/1714204693174.png" /></p>
<h4 id="3nf">3NF 检查</h4>
<p>只需要根据定义，利用属性闭包检查 <strong>F</strong> 中的函数依赖关系</p>
<h4 id="3nf_1">分解为3NF</h4>
<blockquote>
<p>Lossless decomposition &amp; Dependence preservation</p>
</blockquote>
<p>3NF synthesis algorithm</p>
<p><img alt="1714219561539" src="../image/Database/1714219561539.png" /></p>
<h3 id="bcnfboyce-codd-normal-form">BCNF(Boyce-Codd Normal Form)</h3>
<p><img alt="1713407681831" src="../image/Database/1713407681831.png" /></p>
<p>在第三范式的基础上，要求主属性对所有候选键不能有部分依赖，或者通俗地说，对F+中的任意一组依赖关系<span class="arithmatex">\(X\rightarrow Y\)</span>，X一定是candidate key之一。</p>
<p>对下面这个例子：</p>
<ul>
<li>
<p>关系模式：仓库（仓库名，管理员，物品名，数量）</p>
</li>
<li>
<p>已知函数依赖：</p>
<ul>
<li>
<p>仓库名-&gt;管理员</p>
</li>
<li>
<p>管理员-&gt;仓库名 （一个仓库只有一名管理员，一名管理员只能负责一个仓库）</p>
</li>
<li>
<p>（仓库名，物品名）-&gt;数量</p>
</li>
<li>
<p>（管理员，物品名）-&gt;数量</p>
</li>
</ul>
</li>
<li>
<p>candidate key有：</p>
<ul>
<li>
<p>（仓库名，物品名）</p>
</li>
<li>
<p>（管理员，物品名）</p>
</li>
</ul>
</li>
<li>
<p>所以主属性有：仓库名，物品名，管理员</p>
</li>
</ul>
<p>这个关系满足3NF，但是注意到存在 <strong>仓库名-&gt;管理员</strong> 依赖，这是主属性对候选键的部分依赖，或者说仓库名（X）不是candidate key，所以这个例子不满足BCNF。满足BCNF的分解是：</p>
<ul>
<li>
<p>管理（仓库名， 管理员）</p>
</li>
<li>
<p>储存（仓库名，物品名，数量）</p>
</li>
</ul>
<h4 id="bcnf">检查BCNF</h4>
<ul>
<li>
<p>对于一个函数依赖集F的检查：</p>
<p>检查 <strong>F</strong>（<strong>不需要F+</strong>）内所有非平凡的函数依赖，计算左侧属性的闭包，如果闭包包含所有属性，就说明这个依赖满足BCNF</p>
</li>
<li>
<p>对于分解后的关系的检查：</p>
<p>此时上一种情况的条件不满足，必须检查 <strong>F+</strong> 中所有的非平凡的函数依赖</p>
</li>
<li>
<p>另一种通用方法：</p>
<p>对于某个分解后的关系 <span class="arithmatex">\(R_i\)</span> 的每个子集 <span class="arithmatex">\(\alpha\)</span>，确保 <span class="arithmatex">\(\alpha ^+\)</span> 要么包含 <span class="arithmatex">\(R_i\)</span> 的所有属性，要么不包含 <span class="arithmatex">\(R_i - \alpha\)</span> 的任何属性</p>
<p>否则，函数依赖 <span class="arithmatex">\(\alpha \rightarrow (\alpha^+ - \alpha) \cap R_i\)</span> 违反了BCNF</p>
</li>
</ul>
<h4 id="bcnf_1">分解为BCNF</h4>
<blockquote>
<p>Lossless decomposition but may not dependence preservation</p>
</blockquote>
<p>本质上，就是将一个不满足BCNF的关系从表中拆出去，单独建表</p>
<p><strong>其中 <span class="arithmatex">\(\alpha \cap \beta = \emptyset\)</span> 的条件很重要，否则 <span class="arithmatex">\(R_i - \beta\)</span> 会将 <span class="arithmatex">\(\alpha \cap \beta\)</span> 部分的属性拆出去，破坏了 <span class="arithmatex">\(\alpha \rightarrow \beta\)</span> 的函数依赖</strong></p>
<p><img alt="1714218355781" src="../image/Database/1714218355781.png" /></p>
<h3 id="4nf">多值依赖 &amp; 4NF</h3>
<h4 id="_16">多值依赖</h4>
<blockquote>
<p><span class="arithmatex">\(\alpha \rightarrow \rightarrow \beta\)</span> 表明 <span class="arithmatex">\(\alpha\)</span> 的每个值都对应于 <span class="arithmatex">\(\beta\)</span> 的一个或多个值，另一种说法是 <span class="arithmatex">\(\alpha\)</span> 与 <span class="arithmatex">\(\beta\)</span> 之间的联系是一对多且独立于其他属性的。</p>
<p>（因此函数依赖本质上是一种特殊的多值依赖，多值依赖的处理方法和函数依赖也基本一致）</p>
<p><em>若关系r不满足给定的多值依赖，可以通过向r中增加元组来得到一个满足多值依赖的关系</em></p>
</blockquote>
<p>函数依赖&amp;多值依赖的闭包 D+：</p>
<ul>
<li>
<p><span class="arithmatex">\(\alpha \rightarrow \beta \implies \alpha \rightarrow \rightarrow \beta\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(\alpha \rightarrow \rightarrow \beta \implies \alpha \rightarrow \rightarrow R - \alpha - \beta\)</span></p>
</li>
</ul>
<h4 id="4nf_1">4NF</h4>
<ul>
<li>
<p>定义
    4NF 一定是 BCNF，但是反之不一定成立</p>
<p><img alt="1714222354620" src="../image/Database/1714222354620.png" /></p>
</li>
<li>
<p>检查</p>
<p><img alt="1714222416851" src="../image/Database/1714222416851.png" /></p>
</li>
<li>
<p>分解</p>
<p><img alt="1714222443565" src="../image/Database/1714222443565.png" /></p>
</li>
</ul>
<h3 id="more">More</h3>
<h4 id="more-nfs">More NFs</h4>
<ul>
<li>
<p>5NF(Project-Join Normal Form)</p>
</li>
<li>
<p>DKNF(Domain-Key Normal Form) </p>
</li>
</ul>
<h4 id="temporal-data">Temporal data</h4>
<ul>
<li>
<p>Temporal functional dependency: 在任意时间快照上满足的函数依赖</p>
</li>
<li>
<p>实际操作：给数据加上start time和end time，然后用时间戳来查询</p>
</li>
</ul>
<h4 id="how-to-find-candidate-key"><em>How to Find Candidate Key</em></h4>
<ul>
<li>
<p>Primary Attribute</p>
<p>出现在至少一个candidate key中的属性称为主属性。反之为非主属性。</p>
</li>
<li>
<p>第一步-先找主属性</p>
<p>先找出<span class="arithmatex">\(F_c\)</span>或<span class="arithmatex">\(F_m\)</span>，然后将所有属性分为以下四类：</p>
<ul>
<li>
<p><strong>L类：</strong>仅存在于依赖左侧，一定是主属性</p>
</li>
<li>
<p><strong>R类：</strong>仅存在于依赖右侧，一定不是主属性</p>
</li>
<li>
<p><strong>N类：</strong>没有在任何函数依赖中出现过，一定是主属性，且存在于任何一个候选码中</p>
</li>
<li>
<p><strong>LR类：</strong>同时出现在了依赖两侧，<strong>待定</strong></p>
</li>
</ul>
</li>
<li>
<p>第二步-找Candidate Key</p>
<p>这里是根据<span class="arithmatex">\(F_c\ or\ F_m\)</span>分类，可以直接将L类和N类属性合并，检查其是不是candidate key。如果是根据原始关系集F分类，那么还需要逐一对N类属性与L类的所有子集的并集检查是不是candidate key，并不建议这么做。</p>
<ul>
<li>
<p>如果仅靠L类和N类就可以确定candidate key，则不需要考虑LR类。</p>
</li>
<li>
<p>如果L类与N类的并集不是candidate key，那么这个并集与LR类的所有子集逐一取并集检查是不是candidate key。确定一个candidate key后，真包含它的所有集合都不是candidate key，可以减少一些运算量。</p>
</li>
</ul>
</li>
</ul>
<h4 id="design-guidelines">Design Guidelines</h4>
<ul>
<li>
<p>Nice E-R design -&gt; Good relational schema -&gt; Less normalization</p>
</li>
<li>
<p>Duplicated name &amp; relation if properties have some relation</p>
</li>
<li>
<p>Allowing some redundancy for performance(denormalization &amp; materialized view)</p>
</li>
</ul>
<hr />
<h2 id="_17">十二章 物理储存介质</h2>
<p><img alt="1714016769851" src="../image/Database/1714016769851.png" /></p>
<h3 id="_18">储存的评价</h3>
<p><img alt="1714017092504" src="../image/Database/1714017092504.png" /></p>
<h3 id="_19">储存的分类</h3>
<ul>
<li>
<p><strong>储存可以根据易失性分为：</strong></p>
<ul>
<li>
<p>volatile 掉电失去数据，一般容量小速度快</p>
</li>
<li>
<p>non-volatile 掉电不会失去数据，相对容量大速度慢</p>
</li>
</ul>
</li>
<li>
<p><strong>也可以根据层级分类：</strong></p>
<ul>
<li>
<p>primary storage 最快、一般用volatile介质实现</p>
</li>
<li>
<p>secondary storage 较快、非易失</p>
<ul>
<li>也叫on-line storage，常见的flash memory、magnetic disks都属于此类</li>
</ul>
</li>
<li>
<p>teriay storage 慢、非易失</p>
<ul>
<li>也叫off-line storage，magnetic tape、optical storage属于此类</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>也可以根据原理分类：</strong></p>
<p><img alt="1714016897776" src="../image/Database/1714016897776.png" /></p>
</li>
<li>
<p><strong>Measures</strong></p>
<ul>
<li>
<p>Disk block: logical unit for storage allocation and retrieval</p>
<ul>
<li>
<p>Too small : <strong>more transfer</strong></p>
</li>
<li>
<p>Too large : <strong>space wasted</strong></p>
</li>
</ul>
</li>
<li>
<p>Sequential access pattern: seek required only for first block</p>
</li>
<li>
<p>Random access pattern: each access require a seek</p>
</li>
<li>
<p>I/O opeartions per second(IOPS)</p>
</li>
</ul>
</li>
</ul>
<h3 id="_20">磁盘性能评价</h3>
<p><strong>磁盘性能从以下维度评价：</strong></p>
<ul>
<li>
<p><strong>Access time</strong> 访问时间</p>
<ul>
<li>对HDD又可以细分为Seek time寻道时间(4 ~ 10 milliseconds)和Rotation latency旋转延迟(5 ~ 20 milliseconds)</li>
</ul>
</li>
<li>
<p><strong>Data-transfer rate</strong> 数据传输速率(25 ~ 200 MBps)</p>
</li>
<li>
<p><strong>IOPS</strong> 每秒I/O操作数</p>
</li>
<li>
<p><strong>Mean time of failure</strong> 平均故障时间(MTTF, 3 ~ 5 years)</p>
</li>
</ul>
<p>根据所访问数据的储存位置，可以将访问分为随机访问和顺序访问。顺序访问的上限主要由传输速率决定；随机访问的上限主要由IOPS决定，IOPS又主要由访问时间决定。</p>
<p><strong>优化磁盘性能的常见方式：</strong></p>
<ul>
<li>
<p>Buffering 缓冲区，避免重复读写相同数据</p>
</li>
<li>
<p>Read-ahead 预读取</p>
</li>
<li>
<p>Disk-arm-scheduling 针对HDD，相比让磁头来回横跳，适当重排IO请求,像电梯一样，使磁头有序移动能减少平均寻道时间</p>
</li>
<li>
<p>File Organization 针对HDD，文件整理，使数据分布尽可能有序</p>
</li>
<li>
<p>Wear Leveling 针对NVM和SSD，因为擦写寿命相对有限，需要实现负载均衡</p>
</li>
<li>
<p>Non-volatile write buffers 延迟后大批量一同写入</p>
</li>
<li>
<p>Effective query processing algorithm (high-level optimization)</p>
</li>
</ul>
<hr />
<h2 id="_21">十三章 数据储存结构</h2>
<p>一方面，你如何储存一个数据库，是每一张表对应一个文件，还是一个数据库对应一个大文件，还是其他的实现方式？在特定实现方式上怎么优化增删查改？</p>
<p>另一方面你的数据结构怎么与储存介质相配合优化，比如最重要的怎么以扇区为单位大小读写？</p>
<h3 id="_22">单条记录</h3>
<h4 id="_23">定长数据</h4>
<p>按行存放（<strong>Row-Oriented Storage</strong>）的定长数据的增查改都容易实现（一般不允许跨block存储），删除一般有三种方式：</p>
<ul>
<li>
<p>删除后将后面的数据前移（可以保持某些键的顺序）</p>
</li>
<li>
<p>删除后的空位用链表（free list）串联供下次插入用</p>
</li>
<li>
<p>删除后将最下面的一个数据移到删除后的空位</p>
</li>
</ul>
<p>但是数据还可以按列存放，称为<strong>Columnar Representation或Column-Oriented Storage</strong>：</p>
<ul>
<li>
<p>增删查改的实现与上面类似</p>
</li>
<li>
<p>按列存放更有利于向量运算以及数据分析、运算、压缩等操作</p>
</li>
<li>
<p>如果按属性访问多于按tuple访问，这种储存方式会更快</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">materials</p>
<ul>
<li>可以支持向量操作（与编译结合）</li>
</ul>
<p><img alt="1718636161938" src="../image/Database/1718636161938.png" /></p>
</div>
<h4 id="_24">不定长数据</h4>
<ul>
<li>
<p>用null-bit map解决允许为NULL的数据储存。n个允许为空的属性需要n个bit的空位图，空位图中某一bit为0/1意味着对应的属性不是/是空的。</p>
<p>需要注意的是memory一般不允许以bit为单位的读写，需要用n不能被8整除时需要补齐到8的整倍数以实现Byte为单位的读写。</p>
</li>
<li>
<p>用定长的数据，如长度或者偏移量，间接表达长度不定的数据，而将具体的数据存在定长的属性值的后面。</p>
</li>
</ul>
<p>最常见的结构如图所示：</p>
<ul>
<li>
<p>定长的数据和不定长数据的定长表示放前面</p>
</li>
<li>
<p>空位图放中间</p>
</li>
<li>
<p>不定长数据的本体放后面</p>
</li>
</ul>
<p>例如图中(21, 5)表达了一个变长属性的从21号bit开始且长度为5。（65000为一个定长的属性，放在前面）</p>
<p><img alt="1715221718522" src="../image/Database/1715221718522.png" /></p>
<h3 id="_25">数据页</h3>
<p>定长数据非常容易构建数据页。</p>
<p>不定长数据的数据页一般采用两头夹击的结构便于对齐。最常见的实现方式如图，<strong>Slotted page（分槽页）</strong> Header包含本页中records相关信息：</p>
<ul>
<li>
<p>record数量，方便下一次插入record指针，防止将free space中的数据视为record指针</p>
</li>
<li>
<p>free space末尾位置，方便下一次插入record</p>
</li>
<li>
<p>指向各record的指针（一般是偏移量形式）</p>
</li>
</ul>
<p><img alt="1715221964148" src="../image/Database/1715221964148.png" /></p>
<h3 id="_26">文件组织</h3>
<p>需要设计单条数据和数据页如何分布在文件内部。下图是几种常见的结构：</p>
<p><img alt="1715222315167" src="../image/Database/1715222315167.png" /></p>
<h4 id="heap">Heap</h4>
<p>Heap常用的优化方式是Free-space map，剩余空间图中的元素表示对应的block中剩余空间的比例，即<span class="arithmatex">\(\frac{x}{2^{bit}}\)</span>的部分为空闲的</p>
<p>当数据页比较多时，可以将连续K个map的最大值作为键值，建立起二级索引，以加快查找速度</p>
<p><img alt="1716362796517" src="../image/Database/1716362796517.png" /></p>
<h4 id="sequential">Sequential</h4>
<p>这里的Sequential不是指储存空间上有序，而是指每一条数据逻辑关系（<strong>即搜索码</strong>）上有序。在数据经常按某种排序先后取用时，可以考虑顺序文件系统。</p>
<p>先后逻辑一般用类似指针的结构实现，但是会导致数据逻辑存储顺序和物理存储顺序不一致，效率低下，因此需要适时Reorganize。</p>
<ul>
<li>
<p>插入：先定位到对应插入位置，若当前block内有剩余空间可以直接插入，否则将数据存入“溢出块”中，利用指针结构连接起来。</p>
</li>
<li>
<p>删除：改变指针指向以改变逻辑先后关系。空余位置的处理视单条数据的结构而定，猜测可以用链表结构连接起来。</p>
</li>
</ul>
<h4 id="multitable-clustering">Multitable Clustering</h4>
<p>同一个文件页中存储不同的数据表，可以利用链表结构连接起来，以加快单表查询速度。</p>
<ul>
<li>
<p>优点：</p>
<p>加快了多表查询，特别是join操作</p>
</li>
<li>
<p>缺点：</p>
<p>不同的数据格式，降低了存储效率，并且访问单表时需要读取更多的block</p>
<p>一旦有一张表需要更新，整个文件页都需要更新，导致了大量的I/O操作</p>
</li>
</ul>
<h4 id="table-partitioning">Table Partitioning</h4>
<p>某一些表可以从物理上分为多个文件以配合实际使用情况，降低表的大小，提高数据库效率。</p>
<div class="admonition example">
<p class="admonition-title">Example</p>
<p>例如选课信息表，虽然从逻辑上所有学年的选课信息都在同一张表上，但是因为往年的数据几乎不需要增删查改，数据操作集中于当前学年，所以可以进行拆分，将历史信息存储到磁盘中，只保留当前学年的数据在内存中，从而加速查询。</p>
</div>
<h4 id="b-tree-file-index">B+ Tree File Index</h4>
<p>B+树不仅可以作为索引的结构，还可以直接作为文件组织的结构。在下一章中会进行详细介绍。</p>
<h3 id="data-dictionarysystem-catalog-storage">Data Dictionary（System Catalog） Storage</h3>
<p>上面的三类文件组织都是对库中的实例而言的，但是数据库还有一些框架性的全局的信息需要储存，我们称为元数据Metadata。</p>
<p><img alt="1716363840760" src="../image/Database/1716363840760.png" /></p>
<p>为了简化系统的设计，可以直接使用前面的文件组织结构，使用数据表的方式储存元数据。</p>
<h3 id="buffer-management">Buffer Management</h3>
<p>数据库系统的一个重要目标就是 <strong>减少内存和磁盘之间的I/O操作</strong>，这就需要一个缓冲区管理器。</p>
<h4 id="pin">Pin</h4>
<p>钉住正在读写的数据块直到操作完成，防止被替换出去影响数据的一致性。</p>
<p>实现时可以用一个pin count来记录当前被钉住的次数也即承载的操作数，当pin count为0时，可以被替换出去。</p>
<h4 id="lock">Lock</h4>
<ul>
<li>
<p><strong>Exclusive Lock</strong></p>
<p>一般用于写操作，防止其他事务读写该数据块，因此同一时间只能有一个事务对该数据块加上Exclusive Lock。</p>
</li>
<li>
<p><strong>Shared Lock</strong></p>
<p>一般用于读操作，防止其他事务写该数据块而影响数据读取，因此同一时间可以有多个事务对该数据块加上Shared Lock</p>
</li>
</ul>
<h4 id="buffer-replacement">Buffer Replacement</h4>
<p>每次向缓存请求数据时，若该数据已在缓存中，直接返回；若不在缓存中，需要替换一个数据块来存放新数据，即将一个数据块写回磁盘，再将新数据块读入缓存。</p>
<p>操作系统最常用的是LUR策略，（<strong>L.east R.ecently U.sed Stratergy</strong>），即根据“最近访问过的内容更有可能再次被访问”的原则管理缓存内容，将最久未使用的数据块替换出去。</p>
<p>但数据库系统一般基于历史信息和数据情况进行预测，使用更复杂更高效的混合策略</p>
<ul>
<li>其他策略、</li>
</ul>
<p><img alt="1716365031561" src="../image/Database/1716365031561.png" /></p>
<h4 id="force-output">Force Output</h4>
<p>一般用于处理系统崩溃时的数据一致性问题</p>
<p><img alt="1716365193120" src="../image/Database/1716365193120.png" /></p>
<hr />
<h2 id="_27">十四章 索引</h2>
<p>索引是数据库中的一个重要概念，它可以加速数据库的操作，提高数据库的性能。</p>
<p>但是索引会增加数据库的存储空间，并且需要实时维护。</p>
<h3 id="_28">顺序/无序索引</h3>
<p>指key有一定顺序的索引。与之对应的，典型的非顺序作引例如哈希索引。顺序索引可以根据不同的排序规则进一步分类：</p>
<ul>
<li>
<p>Primary Index (clustering index):</p>
<p>索引的顺序与物理储存的顺序对应。（物理储存顺序往往是根据Primary key，当然这里的search key不一定要求是primary key）</p>
</li>
<li>
<p>Secondary Index (non-clustering index):</p>
<p>索引顺序与物理储存顺序不同，根据使用需求设计。</p>
<p>由定义可以知道，辅助索引一定是下面提到的稠密索引，因为他无法通过物理存储顺序进行检索数据。</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>可以看出，当需要线性扫描时，Primary Index的效率更高，因为它的顺序与物理存储顺序一致；而辅助索引可能需要在多个数据块间跳跃</p>
</div>
<h3 id="_29">稠密/稀疏索引</h3>
<ul>
<li>
<p>Dence Index 稠密索引</p>
<blockquote>
<p>指每一个search key的值都在索引列表中出现</p>
</blockquote>
<ul>
<li>
<p>插入</p>
<ul>
<li>
<p>若插入的key值在索引中不存在，直接插入到合适的位置</p>
</li>
<li>
<p>若插入的key值在索引中存在，根据索引情况判断：</p>
<ul>
<li>
<p>若索引存储所有记录的指针，直接插入到合适的位置</p>
</li>
<li>
<p>若索引仅存储相同搜索码值的第一个记录的指针，则把插入的记录插入到该组记录的后面</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>
<p>若删除的索引唯一，直接删除</p>
</li>
<li>
<p>同样考虑索引存储情况</p>
<ul>
<li>
<p>若索引存储所有记录的指针，直接删除；</p>
</li>
<li>
<p>若索引仅存储相同搜索码值的第一个记录的指针，直接删除记录，若恰好为第一个记录，则删除后将指针指向下一个记录</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Sparse Index 稀疏索引</p>
<blockquote>
<p>指只有部分search key的值在索引列表中出现</p>
</blockquote>
<ul>
<li>
<p>插入</p>
<ul>
<li>直接将记录插入到合适的位置，若恰好为当前块的第一条，则更新索引</li>
</ul>
</li>
<li>
<p>删除</p>
<ul>
<li>
<p>直接删除记录</p>
</li>
<li>
<p>若该记录有索引指向：</p>
<ul>
<li>
<p>若该记录的搜索码值唯一，则用下一个搜索码值的指针替代（若下一个搜索码值已经存在索引中，则直接删除当前索引） </p>
</li>
<li>
<p>若该记录的搜索码值不唯一，则将索引指向下一个记录</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>稀疏索引可以多级嵌套，配合顺序索引就是B+树（当然还要附加其他一些约束）</p>
<h3 id="composite-search-key"><em>多值索引（Composite Search Key）</em></h3>
<p>一般按照类似字典序的方式进行排序</p>
<h3 id="b">B+树索引</h3>
<p>和ADS课上的版本略有不同，要非常小心</p>
<p><img alt="1716368536510" src="../image/Database/1716368536510.png" /></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>注意这里的 n 一致指上面图中的 n</strong></p>
<p>根节点：<span class="arithmatex">\([2, n]\)</span> 个孩子指针</p>
<p>内部节点：<span class="arithmatex">\([\lceil \frac{n}{2} \rceil, n]\)</span> 个孩子指针</p>
<p>叶子节点：<span class="arithmatex">\([\lceil \frac{n-1}{2} \rceil, n-1]\)</span> 个记录对（搜索码+记录指针），最后一个（即上图的Pn）指向下一个叶子节点，从而将底层记录串联成线性表</p>
<p>一个页中可以存放的B+树索引个数为：
$$
单页中索引个数n=\frac{页大小-指针大小}{索引数据大小+指针大小}+1
$$</p>
<p>树的高度</p>
<div class="arithmatex">\[h \leq \lceil \log_{\lceil \frac{n}{2} \rceil} K \rceil\]</div>
</div>
<details class="计算">
<summary>计算</summary>
<p><img alt="1716369970314" src="../image/Database/1716369970314.png" /></p>
</details>
<ul>
<li>
<p>Operations</p>
<p>与ADS课上所学基本一致，略</p>
<p>一般前面节点分到 <span class="arithmatex">\(\lceil \frac{n}{2} \rceil\)</span> 个key</p>
</li>
<li>
<p>Extensions</p>
<ul>
<li>
<p>对于<strong>Non-Unique</strong>的搜索码，可以附加记录的主键将其组成一个复合搜索码，从而实现Unique索引。</p>
</li>
<li>
<p><strong>B+树文件结构</strong>，叶节点不是指针而是记录本身即可</p>
<details class="note">
<summary>B+树文件索引</summary>
<p><img alt="1718673782319" src="../image/Database/1718673782319.png" /></p>
<p><img alt="1718675613503" src="../image/Database/1718675613503.png" /></p>
</details>
</li>
<li>
<p><strong>辅助索引的记录重定位</strong>代价较高，因此可以让辅助索引的叶结点直接存储搜索码而不是记录指针，这样可以减少重定位代价（即更新索引的代价），但是在查询时需要额外代价作相应搜索码查找</p>
</li>
<li>
<p><strong>字符串索引</strong>，进行前缀压缩，从而减少索引的大小</p>
</li>
<li>
<p><strong>多码访问</strong></p>
<ul>
<li>
<p>多个单码索引</p>
</li>
<li>
<p>使用多值索引</p>
</li>
<li>
<p>覆盖索引，即在索引中直接存储一些数据，这样直接查询索引即可，不需要再去查询数据表</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="_30">相关优化</h3>
<ul>
<li>
<p>批量插入BULK LOADING：</p>
<ul>
<li>
<p>一个一个插入显然代价过高</p>
</li>
<li>
<p>插入之前先进行排序，比乱序插入更新索引的代价小，尤其对于B+树索引而言。</p>
<p><img alt="1718675267089" src="../image/Database/1718675267089.png" /></p>
</li>
<li>
<p>对B+树，批量插入还可以直接建叶节点，然后自叶向根Bottom-up插入，减少了插入时的IO操作</p>
</li>
</ul>
</li>
<li>
<p>内存索引：</p>
<ul>
<li>
<p>对disk而言，与磁盘页大小相匹配的size的索引更快，因为磁盘IO的最小单位是扇区</p>
</li>
<li>
<p>而对mem和cache而言，小节点size更快因为随机访问性能高得多并且没有扇区大小限制</p>
</li>
</ul>
</li>
<li>
<p><strong>写优化</strong> - LSM-Tree(Log Structured Merge Tree)：</p>
<ul>
<li>
<p>多级树型索引分别放在不同层次的储存上</p>
<p><img alt="1716510339016" src="../image/Database/1716510339016.png" /></p>
<ul>
<li>
<p>保证了写入的速度，并充分利用了空间（先往更快的mem写，写满后再一次性向下合并完成写入）</p>
</li>
<li>
<p>减少了磁盘的写入量（因为磁盘IO的最小单位是扇区，单次大量写入对磁盘的消耗远小于多次少量写入）</p>
</li>
<li>
<p>但是损失了查询的速度（要在多棵树里找），并且同一数据可能在多棵树中被拷贝</p>
</li>
</ul>
</li>
<li>
<p>如果每一层级允许同时存在多棵树，称为<strong>Setpped-merge index</strong>。进一步用编程难度、空间复杂度和查询速度换写速度。</p>
</li>
<li>
<p>其他操作：</p>
<ul>
<li>
<p>删除： 采用打标记的懒惰删除，只有在合并时才真正删除</p>
</li>
<li>
<p>更新： 采用插入新值+删除旧值的方式</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>写优化</strong> - Buffer Tree</p>
<ul>
<li>
<p>与LSM-Tree有些类似，在每个节点上都有一个buffer，用于缓存写入的数据，当buffer满了之后继续向下写入</p>
<p><img alt="1716510766922" src="../image/Database/1716510766922.png" /></p>
</li>
<li>
<p>同样可以实现大规模写入优化，并且查询速度也不会受到太大影响</p>
</li>
<li>
<p>但是相比LSM-Tree，Buffer Tree的Random I/O还是会相对多一些，因为没有严格保持有序 </p>
</li>
</ul>
</li>
</ul>
<h3 id="hash">Hash索引</h3>
<ul>
<li>
<p>静态散列</p>
<ul>
<li>
<p>使用溢出桶来解决桶溢出（桶不足、偏斜）</p>
</li>
<li>
<p>解决冲突可以用链表、开放寻址法等</p>
</li>
<li>
<p>可以周期性rehash, 相当于重建整个哈希表，但是代价较高 </p>
</li>
</ul>
</li>
<li>
<p>动态散列</p>
<ul>
<li>
<p>Periodic ReHashing，周期性将桶的个数翻倍</p>
</li>
<li>
<p>Linear Hashing， 增大rehash的条件</p>
</li>
<li>
<p>Extendable Hashing，生成的哈希值为多位，但使用的偏移地址的位数是逐渐增加的（即相当于依据当前的数据量翻倍容量）</p>
</li>
</ul>
</li>
</ul>
<h3 id="bitmap">Bitmap索引</h3>
<ul>
<li>
<p>本质上就是用一个简单数组bitmap来映射索引关系，适用于数据量大，取值范围小的情况，此时可以降低索引的空间代价</p>
<p>比如下图，相同为1,不同为0，长度 = 记录总数</p>
<p><img alt="1718676704875" src="../image/Database/1718676704875.png" /></p>
</li>
<li>
<p>核心优势在于<strong>位操作</strong>，可以快速进行<strong>位运算</strong>，如AND、OR、NOT等，因此适用于<strong>多值查询</strong>，如多值查询、范围查询等</p>
</li>
</ul>
<hr />
<h2 id="_31">十五章 查询操作</h2>
<p>对数据库的任何一个查询操作都大致可以分为一下三个步骤：</p>
<ol>
<li>
<p>解析和翻译：检查所输入语句的语法正确性，并将其翻译成机器能够读懂的形式。</p>
</li>
<li>
<p>优化：从众多可选的执行方法中选择最优的一种方法。</p>
</li>
<li>
<p>执行：按照前一步决定的方法执行并返回结果。</p>
</li>
</ol>
<p>考虑的参数：</p>
<p><img alt="1716603229316" src="../image/Database/1716603229316.png" /></p>
<p>（一般来说seek时间大于transfer时间）</p>
<h3 id="selection">Selection</h3>
<h4 id="equations">Equations</h4>
<ul>
<li>
<p>A1 (Linear Scan)</p>
<p>线性扫描，通过一次寻道找到起始位置，然后扫描所有数据块（同样很容易应用到任何条件的查询）</p>
<p>所需的时间是<span class="arithmatex">\(b_r\times t_T+ 1 \times t_s\)</span>（<span class="arithmatex">\(b_r\)</span>为数据表所含的数据块个数）</p>
<p><em>当属于键值记录查找（找到就停）时，平均时间为<span class="arithmatex">\(\frac{b_r}{2} \times t_T+ 1 \times t_s\)</span></em></p>
</li>
<li>
<p>A2/A3 (Primary Index Scan)</p>
<p>利用索引优化查询速度，同样考虑单点key查询与多数据查询</p>
<ul>
<li>
<p>单点查询（key），先通过索引树结构定位到数据库，再通过一次定位+读取获得对应数据内容</p>
<p>时间代价为<span class="arithmatex">\((h_i+1)\times (t_T+t_s)\)</span>，其中<span class="arithmatex">\(h_i\)</span>是索引的层数</p>
</li>
<li>
<p>多点查询（non-key），最后可能要到多个数据库读取数据，因此要额外的一次定位+多次读取数据块</p>
<p>时间代价为<span class="arithmatex">\(h_i \times (t_T + t_s) + t_s + b \times t_T\)</span>，<span class="arithmatex">\(b\)</span>为涉及的数据块</p>
</li>
</ul>
</li>
<li>
<p>A4 (Secondary Index scan)</p>
<p>利用辅助索引进行搜索。</p>
<ul>
<li>
<p>单点查询（key）与聚集索引相同，为<span class="arithmatex">\((h_i+1)\times (t_T+t_s)\)</span></p>
</li>
<li>
<p>多点查询（non-key），无法通过一次定位后顺序扫描，因此需要在索引树上多次定位+读取数据块</p>
<p>时间代价为<span class="arithmatex">\((h_i + b)\times (t_T + t_s)\)</span>，<span class="arithmatex">\(b\)</span>为涉及的数据块 </p>
</li>
</ul>
</li>
</ul>
<h4 id="comparison">Comparison</h4>
<p><em>直接使用线性扫描肯定没有问题，下面是使用索引辅助的方法</em></p>
<ul>
<li>
<p>A5（Clustered Index Scan）</p>
<p><img alt="1718678500725" src="../image/Database/1718678500725.png" /></p>
</li>
<li>
<p>A6（Non-Clustered Index Scan）</p>
<p>（非聚集索引，每次都必须重新seek+transfer）</p>
<p><img alt="1718678565587" src="../image/Database/1718678565587.png" /></p>
</li>
</ul>
<h4 id="conjunction">Conjunction</h4>
<ul>
<li>
<p>A7</p>
<p>获取满足部分条件（估计代价最小）的数据存入缓冲区，检查其他条件是否满足</p>
</li>
<li>
<p>A8</p>
<p>通过复合索引进行直接查询</p>
</li>
<li>
<p>A9</p>
<p>每次将结果集合做交集</p>
</li>
</ul>
<p><img alt="1716609288358" src="../image/Database/1716609288358.png" /></p>
<h4 id="disjunction">Disjunction</h4>
<ul>
<li>
<p>A10</p>
<p>对结果集合求并集</p>
<p>容斥原理求补集</p>
</li>
</ul>
<p><img alt="1716609564731" src="../image/Database/1716609564731.png" /></p>
<h4 id="bitmap-index-scan">Bitmap Index Scan</h4>
<p>平衡<strong>辅助索引</strong>查询（散点查询快）与直接扫描（多数据时快）的效率，相当于把物理存储的有序性重新组织出来，从而降低IO操作的代价</p>
<p><img alt="1716609869971" src="../image/Database/1716609869971.png" /></p>
<h3 id="external-sort">External Sort</h3>
<blockquote>
<p>数据的转移需要在buffer中进行，但可能数据过大，无法完整写入buffer,因此需要分段进行多路归并排序</p>
</blockquote>
<p>具体步骤：</p>
<ol>
<li>
<p>将数据按照 缓冲区block数目M 分成N段run，每段内可以调用内部排序算法进行排序</p>
</li>
<li>
<p>将至多M-1段存入缓冲区（此时可以将理解为存了M-1段的指针），剩下一段作为输出指针，执行多路排序算法</p>
<p>对当前所有的run进行一轮merge, 此时每M-1段合并成了一段</p>
</li>
<li>
<p>重复过程2直至所有段合并成一段</p>
</li>
</ol>
<p>复杂度分析：</p>
<blockquote>
<p>考虑到合并时每一段使用一个block所耗费的seek的数量太多，效率下降，可以考虑<span class="arithmatex">\(b_b\)</span>个block作为初始的段长</p>
</blockquote>
<ul>
<li>
<p>每次合并的段数：<span class="arithmatex">\(\lfloor \frac{M}{b_b} \rfloor - 1\)</span></p>
</li>
<li>
<p>合并的总轮数（pass）：<span class="arithmatex">\(\lceil \log_{\lfloor \frac{M}{b_b} \rfloor - 1} (\lceil \frac{b_r}{M} \rceil) \rceil（这里实际上是N = \frac{b_r}{M}）\)</span></p>
</li>
<li>
<p><strong>Transfer</strong></p>
<ul>
<li>
<p>每轮的transfer（线性，读+写）：<span class="arithmatex">\(2b_r\)</span></p>
</li>
<li>
<p>总transfer（忽略最后一次的写，因为可能作为某个输出而不写）：<span class="arithmatex">\(b_r \times (2\lceil \log_{\lfloor \frac{M}{b_b} \rfloor - 1} (\lceil \frac{b_r}{M} \rceil) \rceil + 1)\)</span></p>
</li>
</ul>
</li>
<li>
<p><strong>Seek</strong></p>
<ul>
<li>
<p>生成初始的run（线性读+写）：<span class="arithmatex">\(2 \lceil \frac{b_r}{M} \rceil\)</span></p>
</li>
<li>
<p>每轮的seek：<span class="arithmatex">\(2 \lceil \frac{b_r}{b_b} \rceil\)</span></p>
</li>
<li>
<p>总seek（同样忽略最后一次写）：<span class="arithmatex">\(2 \lceil \frac{b_r}{M} \rceil + \lceil \frac{b_r}{b_b} \rceil \times 2(\lceil \log_{\lfloor \frac{M}{b_b} \rfloor - 1} (\lceil \frac{b_r}{M} \rceil) \rceil - 1)\)</span>  </p>
</li>
</ul>
</li>
</ul>
<h3 id="join_1">Join</h3>
<h4 id="nested-loop-join">Nested-Loop Join</h4>
<p><img alt="1716619726979" src="../image/Database/1716619726979.png" /></p>
<p>Worst Case： buffer只有2个block, 一个用于读取R，一个用于读取S</p>
<ul>
<li>
<p>transfer: <span class="arithmatex">\(b_r + n_r \times b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(b_r + n_r\)</span></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>这里需要考虑所谓的连续性 本质上是磁盘的物理结构决定的，seek即磁盘的磁头寻道</p>
<p>比如这里内层循环后磁头的位置已经改变了，因此回到外循环时要重新寻道回去</p>
</div>
<p>Best Case： buffer可以全部存下</p>
<ul>
<li>
<p>transfer：<span class="arithmatex">\(b_r + b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(1 + 1 = 2\)</span></p>
</li>
</ul>
<h4 id="block-nested-loop-join">Block Nested-Loop Join</h4>
<p>仍然是循环结构，但是以block为外关系的单位。</p>
<p><img alt="1716622172663" src="../image/Database/1716622172663.png" /></p>
<p>Worst Case：buffer小</p>
<ul>
<li>
<p>transfer：<span class="arithmatex">\(b_r + b_r \times b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(2 b_r\)</span></p>
</li>
</ul>
<p>Best Case: buffer足够</p>
<ul>
<li>
<p>transfer: <span class="arithmatex">\(b_r + b_r\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(1 + 1\)</span></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>折中的优化方法：<strong>注意到外循环的<span class="arithmatex">\(b_r\)</span>作为乘积项影响很大，考虑将buffer中M-2个block作为外循环的单位，降低外循环的复杂度</strong></p>
<p>这样相当于将外部循环的次数变为了<span class="arithmatex">\(\lceil \frac{b_r}{M-2} \rceil\)</span></p>
<ul>
<li>
<p>transfer: <span class="arithmatex">\(b_r + \lceil \frac{b_r}{M-2} \rceil \times b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(2 \lceil \frac{b_r}{M-2} \rceil\)</span>  </p>
</li>
</ul>
</div>
<h4 id="indexed-nested-loop-join">Indexed Nested-Loop Join</h4>
<p>考虑使用索引来加速内层循环的查询</p>
<p>Worst Case：buffer小</p>
<p>由于索引查询有前面提到的各种策略，这里用一个常数<span class="arithmatex">\(c\)</span>来代表一次查询操作的代价</p>
<p>则总代价为：<span class="arithmatex">\(b_r \times (t_T + t_s)+ n_r \times c\)</span></p>
<p>可以看出，这里的代价受外循环的影响较大，<strong>因此应该尽量选择数目较小的表作为外循环</strong></p>
<h4 id="sort-merge-join">Sort-Merge Join</h4>
<blockquote>
<p><strong>只适用于取等号（自然连接）这种的</strong></p>
</blockquote>
<p>用类似归并算法的双指针方法，对两个有序表进行join</p>
<p>若<strong>不考虑排序</strong>，可以做到线性时间复杂度，显然效率非常高</p>
<ul>
<li>
<p>transfer: <span class="arithmatex">\(b_r + b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(\lceil \frac{b_r}{b_{br}} \rceil + \lceil \frac{b_s}{b_{bs}} \rceil\)</span></p>
</li>
</ul>
<div class="admonition hybrid-merge join">
<p class="admonition-title">Hybrid-merge</p>
<p>若其中一个表有序，而另一个表具有辅助索引，可以将有序表与辅助索引的叶子节点进行合并，得到一个混合的地址数据表</p>
<p>然后按地址进行排序，加快读取的速度，完成join</p>
</div>
<h4 id="hash-join">Hash Join</h4>
<blockquote>
<p>同样只适用于取等号的情况，本质利用相同属性值的哈希值相同的特点（相同哈希值不一定属性相同），对数据进行分块处理</p>
</blockquote>
<ul>
<li>
<p>分块：将两个表分别使用hash进行分块，分成 <span class="arithmatex">\(n_h\)</span> 个partition </p>
</li>
<li>
<p>其中一个表作为build input，用<strong>另一个hash函数</strong>对每一个 partition 在内存中建立hash索引</p>
</li>
<li>
<p>另一个表作为probe input，直接读取相应partition的数据，根据后面建立的hash索引在 build input 的索引中查找相应的join目标</p>
</li>
</ul>
<p><img alt="1716639743086" src="../image/Database/1716639743086.png" /></p>
<p>首先，划分时partition的个数不能超过内存总block数，不然无法正确划分（要为每一个partition留一个output buffer）</p>
<p>划分后每个partition的大小应该控制在buffer的大小内，因为要在内存中为这一块建立一个索引</p>
<div class="arithmatex">\[ \lceil \frac{b_s}{M} \rceil \times f \leq n_h \leq M \]</div>
<p>（ <span class="arithmatex">\(f\)</span>（fudge factor）为避让系数用于降低下述散列表溢出的概率）</p>
<ul>
<li><strong>Recursive Partition</strong></li>
</ul>
<p>由上可知，如果数据量太大，<span class="arithmatex">\(M \leq \sqrt{b_s}\)</span>，划分时就无法一趟完成，这时就需要使用多层级的递归划分</p>
<p>每次不够就划分成M-1个子块，然后对每个子块再进行递归划分，直到整个子块可以全部放入buffer</p>
<ul>
<li>
<p><strong>Overflowing</strong></p>
<blockquote>
<p>散列划分出现<strong>偏斜</strong>，导致部分过满，部分过空</p>
</blockquote>
<ul>
<li>
<p>避让因子：<span class="arithmatex">\(f = 1.2\)</span></p>
</li>
<li>
<p>溢出分解：将溢出的部分再次进行散列划分，直到全部放入buffer</p>
</li>
<li>
<p>溢出避免：划分时划分成小块，在不溢出的情况下再合并成大块</p>
</li>
</ul>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>当属性值大量重复时，上述策略可能都会失效，此时可以考虑前面的其他join方法  </p>
</div>
</li>
<li>
<p><strong>代价分析</strong></p>
<ul>
<li>
<p>不需要递归</p>
<ul>
<li>
<p>transfer: </p>
<p><span class="arithmatex">\(2(b_r + b_s)（初始划分读+写） + (b_s + b_r)（索引中探查） + 4 n_h（划分后的多余块，每个partition最多多余1块，一般可以忽略\)</span></p>
<p><span class="arithmatex">\(= 3(b_r + b_s) + 4 n_h\)</span></p>
</li>
<li>
<p>seek: </p>
<p><span class="arithmatex">\(2(\lceil \frac{b_r}{b_{br}} \rceil + \lceil \frac{b_s}{b_{bs}} \rceil) （划分\&amp;写回，一次多读几块）+ (n_h + n_h)（索引中探查）\)</span></p>
<p><span class="arithmatex">\(= 2(\lceil \frac{b_r}{b_{br}} \rceil + \lceil \frac{b_s}{b_{bs}} \rceil) + 2n_h\)</span></p>
</li>
</ul>
</li>
<li>
<p>需要递归</p>
<p>每次递归划分将大小变为原来的 <span class="arithmatex">\(\frac{1}{M-1}\)</span> 直至到 <span class="arithmatex">\(M\)</span>，因此需要<span class="arithmatex">\(\lceil \log_{M-1} (b_s) - 1\rceil\)</span>次递归</p>
<ul>
<li>
<p>transfer: </p>
<p><span class="arithmatex">\(2(b_r + b_s) \times \lceil \log_{M-1} (b_s) - 1\rceil + b_r + b_s\)</span></p>
</li>
<li>
<p>seek: </p>
<p><span class="arithmatex">\(2(\lceil \frac{b_r}{b_{br}} \rceil + \lceil \frac{b_s}{b_{bs}} \rceil) \times \lceil \log_{M-1} (b_s) - 1\rceil\)</span></p>
</li>
</ul>
</li>
<li>
<p>最优情况，buffer足够大，直接退化为简单的O(1)对应：</p>
<ul>
<li>
<p>transfer: <span class="arithmatex">\(b_r + b_s\)</span></p>
</li>
<li>
<p>seek: <span class="arithmatex">\(1 + 1\)</span></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>Hybrid Hash Join</em></p>
<ul>
<li>
<p>当内存较大又不是超级大时，可以考虑将一部分内存用来存第一个划分<span class="arithmatex">\(s_0\)</span>不用写回，并且在处理<span class="arithmatex">\(r_0\)</span>划分时直接当场解决，又少了一次写回的代价</p>
</li>
<li>
<p>一般当<span class="arithmatex">\(M &gt;&gt; \sqrt{b_s}\)</span>时，可以考虑使用这种方法</p>
</li>
</ul>
</li>
</ul>
<h4 id="complex-join">Complex Join</h4>
<p>循环嵌套一起做，或者每次做一个条件后进行集合运算</p>
<p><img alt="1716642948613" src="../image/Database/1716642948613.png" /></p>
<h3 id="other-operations">Other Operations</h3>
<ul>
<li>
<p>Duplicate Elimination</p>
<ul>
<li>
<p>排序去重，相邻的相同元素直接跳过</p>
</li>
<li>
<p>Hash去重，直接避免重复插入</p>
</li>
</ul>
</li>
<li>
<p>Projection</p>
<p>每个元组做投影，然后去重</p>
</li>
<li>
<p>Aggregation</p>
<ul>
<li>
<p>类似去重的方法，对相关属性进行聚合处理</p>
</li>
<li>
<p>还可以考虑从部分聚合开始，逐步向上聚合</p>
</li>
</ul>
</li>
<li>
<p>Set Operations</p>
<p>同样利用 排序/哈希等方法处理</p>
</li>
<li>
<p>Outer Join</p>
<ul>
<li>
<p>先计算出所有的内连接，然后再将外连接的部分补充进去</p>
</li>
<li>
<p>修改连接算法，如嵌套循环连接处理单侧外连接很方便，归并算法处理外连接都很方便</p>
</li>
</ul>
</li>
</ul>
<h3 id="expression">Expression</h3>
<blockquote>
<p>考虑计算含有多个运算的表达式</p>
</blockquote>
<h4 id="materialization">Materialization</h4>
<blockquote>
<p>每个子查询结果都作为一个临时表存储，然后再进行下一步操作</p>
</blockquote>
<p><img alt="1718681894296" src="../image/Database/1718681894296.png" /></p>
<p>可以使用double buffering模型，即两个buffer轮流使用，一个承接数据，一个并行写磁盘，实现buffer写入磁盘时不需要中断当前进程</p>
<p><strong>时间代价 = 两子查询的时间代价 + 两子查询的结果合并写入时间代价</strong></p>
<h4 id="pipeline">Pipeline</h4>
<blockquote>
<p>减少临时文件数，将多个关系操作组合成一个流水线，一个操作的输出直接作为下一个操作的输入</p>
</blockquote>
<p><strong>同一阶段的操作并行运行，但是必须要前面的所有操作都完成后才能进行下一步</strong></p>
<ul>
<li>
<p>Demand-Driven (Lazy) Pipeline - Pull</p>
<p><img alt="1716644558855" src="../image/Database/1716644558855.png" /></p>
</li>
<li>
<p>Producer-Driven (Eager) Pipeline - Push</p>
<p><img alt="1716644586102" src="../image/Database/1716644586102.png" /></p>
</li>
<li>
<p>执行算法</p>
<ul>
<li>
<p>阻塞操作</p>
<p>如sort等，需要等待所有数据到达后再进行操作</p>
</li>
<li>
<p>一些操作可以并行进行处理输入流，如projection和selection</p>
<details>
<summary>double-pipelined join</summary>
<p><img alt="1716645207767" src="../image/Database/1716645207767.png" /></p>
</details>
</li>
</ul>
</li>
</ul>
<details>
<summary>Cache Conscious Algorithm</summary>
<p><img alt="1716644890270" src="../image/Database/1716644890270.png" /></p>
</details>
<hr />
<h2 id="_32">十六章 查询优化</h2>
<p>本章的目的是具体实现如何选择执行语句的最优方案，大致又可以分为两步：</p>
<ol>
<li>
<p>列出与当前语句等价的内部执行方案，这里的执行方案既包括例如交换结合等逻辑层面的内容，也包括具体使用哪一种索引方法等实现层面的内容。</p>
</li>
<li>
<p>快速估算每一种执行方案的复杂度并选其中最优的一种</p>
</li>
</ol>
<h3 id="equivalence-rules">Equivalence Rules</h3>
<blockquote>
<p>查询结果一般为 <strong>Multisets of Tuples</strong>，等价表达式即 在合法的数据库上结果完全相同 <em>（注意集合是无序的）</em></p>
</blockquote>
<p><img alt="1716704968040" src="../image/Database/1716704968040.png" /></p>
<p><img alt="1716704999491" src="../image/Database/1716704999491.png" /></p>
<p><img alt="1716705173860" src="../image/Database/1716705173860.png" /></p>
<p><img alt="1716707417558" src="../image/Database/1716707417558.png" /></p>
<p><img alt="1716707576340" src="../image/Database/1716707576340.png" /></p>
<p><img alt="1716707602951" src="../image/Database/1716707602951.png" /></p>
<p>策略：</p>
<p>通过上述规则将查询语句转化为等价的形式，选择最优的执行方案</p>
<p><em>实际使用中往往是引用经验式的规则，想要列出所有可能的实现逻辑一般是不可能的</em></p>
<p>常用的套路有</p>
<ul>
<li>
<p>Space sharing &amp; Time programming</p>
</li>
<li>
<p>选择提前做selection &amp; projection，减少不需要的行数和列数</p>
</li>
<li>
<p>连续的join先做结果较少的，减少中间结果需要的空间（有点类似动态规划经典问题 矩阵乘法）</p>
</li>
</ul>
<h3 id="statistical-cost-estimation">Statistical Cost Estimation</h3>
<details class="一些定义">
<summary>一些定义</summary>
<p><img alt="1716709482195" src="../image/Database/1716709482195.png" /></p>
</details>
<h4 id="histogram">Histogram</h4>
<blockquote>
<p>记录每个属性取值的频率，需要随着数据库的更新实时更新</p>
</blockquote>
<ul>
<li>
<p>Equi-width：等宽</p>
</li>
<li>
<p>Equi-depth：等高</p>
</li>
</ul>
<h4 id="selection-size-estimation">Selection Size Estimation</h4>
<ul>
<li>
<p>如果有相关的Histogram，直接使用其值即可</p>
</li>
<li>
<p>否则，粗略认为数据满足均匀分布：</p>
<ul>
<li>
<p>单点： <span class="arithmatex">\(\frac{n_r}{V(A,r)}\)</span></p>
</li>
<li>
<p>区域（以小于为例）：</p>
<div class="arithmatex">\[
\left \{
    \begin{aligned}
        0 &amp;\qquad v &lt; min(A,r)\\
        n_r \times \frac{v - \min(A,r)}{max(A,r) - min(A,r)} &amp; \qquad min(A,r) \leq v &lt; max(A,r)\\
        n_r &amp; \qquad v \geq max(A,r)
    \end{aligned}
\right.
\]</div>
<p><em>若毫无相关信息，一般认为满足项为<span class="arithmatex">\(\frac{n_r}{2}\)</span></em></p>
</li>
<li>
<p>复合条件</p>
<p>使用概率分析，对于每个条件，根据前面所述计算其满足的概率<span class="arithmatex">\(\frac{s_i}{n_r}\)</span></p>
<ul>
<li>
<p>Conjunction：<span class="arithmatex">\(n_r \times \prod \frac{s_i}{n_r}\)</span></p>
</li>
<li>
<p>Disjunction（容斥）：<span class="arithmatex">\(n_r \times (1 - \prod (1 - \frac{s_i}{n_r}))\)</span></p>
</li>
<li>
<p>Negation：<span class="arithmatex">\(n_r - n_p\)</span> </p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="join-size-estimation">Join Size Estimation</h4>
<ul>
<li>
<p>笛卡尔积：</p>
<ul>
<li>
<p><span class="arithmatex">\(n_{r\times s} = n_r \times n_s\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(l_{r\times s} = l_r + l_s\)</span></p>
</li>
</ul>
</li>
<li>
<p>自然连接根据 <span class="arithmatex">\(R \cap S\)</span> 的情况估计</p>
<ul>
<li>
<p><span class="arithmatex">\(R \cap S = \emptyset\)</span>，则 <span class="arithmatex">\(R\Join S = R \times S\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(R \cap S \rightarrow R (S)\)</span>，即交集为某一表的主键，则说明每一个元组最多有一个与之匹配，因此<span class="arithmatex">\(n_{r\Join s} \leq n_s(n_r)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(R \cap S\)</span>为外键，此时每一个元组恰好有一个与之匹配，因此<span class="arithmatex">\(n_{r\Join s} = n_r(n_s)\)</span></p>
</li>
<li>
<p><span class="arithmatex">\(R \cap S = A\)</span>非键值，则同样考虑均匀概率分布,对于表中的每一个元组考虑其可能匹配的个数，即相当于上述的给定单值的selection，有<span class="arithmatex">\(n_{r\Join s} = \frac{n_r \times n_s}{max(V(A,r),V(A,s))}\)</span></p>
</li>
</ul>
</li>
<li>
<p>对于一般连接<span class="arithmatex">\(R \Join_{\theta} S\)</span>，可以转化为<span class="arithmatex">\(\sigma_{\theta}(R \times S)\)</span>，然后使用上述方法估计</p>
</li>
<li>
<p>对于外连接，可以看成自然连接+额外元组，有<span class="arithmatex">\(n_{r⟗s} = n_{r\Join s} + n_r + n_s\)</span></p>
</li>
</ul>
<h4 id="other-estimations">Other Estimations</h4>
<p><img alt="1716726772210" src="../image/Database/1716726772210.png" /></p>
<h4 id="estimation-of-distinct-value">Estimation of Distinct Value</h4>
<ul>
<li>
<p>Selection</p>
<ul>
<li>
<p>单点取等： 显然就为条件中的不同值个数</p>
</li>
<li>
<p>区间取值（比大小）： <span class="arithmatex">\(V(A,r) \times P_{select}\)</span></p>
</li>
<li>
<p>复杂情况： 直接粗略估计，<span class="arithmatex">\(min(V(A,r), n_{\sigma_{\theta(r)}})\)</span> </p>
</li>
</ul>
</li>
<li>
<p>Join：</p>
<ul>
<li>
<p>假设<span class="arithmatex">\(A = A_r \cup A_s\)</span>，则<span class="arithmatex">\(V(A,r\Join s) = min(V(A_r,r) \times V(A_s - A_r, s), V(A_r - A_s, r) \times V(A_s, s), n_{r \Join s})\)</span></p>
<p>这里设<span class="arithmatex">\(V(\emptyset,r) = 1\)</span></p>
</li>
</ul>
</li>
<li>
<p>Projection</p>
<ul>
<li><span class="arithmatex">\(V(\Pi_{A}(r),r) = V(A,r)\)</span></li>
</ul>
</li>
<li>
<p>Aggregation</p>
<ul>
<li><span class="arithmatex">\(V(G_F(A),r) = min(V(A,r), V(G,r))\)</span></li>
</ul>
</li>
</ul>
<h3 id="cost-base-optimize">Cost Base Optimize</h3>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<ol>
<li>
<p>局部最优解不一定是整体最优解</p>
<ul>
<li>
<p>hash-join一般更快，但merge-join得到的结果是有序的</p>
</li>
<li>
<p>嵌套的语句计算量不一定最小，但是可以配合流水线提高执行效率，最终时间复杂度反而小</p>
</li>
</ul>
</li>
<li>
<p>适当的选择计划途径，可以列出所有选项还是使用启发式搜索</p>
</li>
</ol>
</div>
<h4 id="join-order-selection">Join-Order Selection</h4>
<p>考虑<span class="arithmatex">\(n\)</span>个连续join，顺序有<span class="arithmatex">\(\frac{(2(n-1))!}{(n-1)!}\)</span>（卡特兰数），可以用类似矩阵连乘的动态规划求解（但是顺序不定）</p>
<ul>
<li>
<p>若选择bushy tree, 复杂度为<span class="arithmatex">\(\sum_{i=1}^{n} \binom{n}{i} \times 2^i = (1+2)^n = O(3^n)\)</span> （考虑大小为i的子集的更新代价为<span class="arithmatex">\(2^i\)</span>）</p>
<p><span class="arithmatex">\(F(S) = min(F(S_k) + F(S - S_k) + Join(S_k, S-S_k))\)</span></p>
</li>
<li>
<p>若为left-deep tree，更新复杂度为<span class="arithmatex">\(O(i)\)</span>，总复杂度降为<span class="arithmatex">\(O(n 2^n)\)</span></p>
<p><span class="arithmatex">\(F(S) = min(F(r) + F(S - r) + Join(r, S-r))\)</span></p>
</li>
</ul>
<details>
<summary>Left Deep Join Tree定义</summary>
<p><img alt="1716728651407" src="../image/Database/1716728651407.png" /></p>
</details>
<ul>
<li>
<p>Interesting Sort Order</p>
<p>如果使用merge-join等操作，前面的排序可能会预先为后面的操作做一些优化</p>
<p>因此这些也要在 DP 的过程中考虑进去，称为真正的 <strong>interesting sort order</strong></p>
</li>
</ul>
<h4 id="cost-based-optimization-with-equivalence-rules">Cost Based Optimization with Equivalence Rules</h4>
<p>通过前面提到的表达式推导的形式寻找最优解，需要解决下述问题：</p>
<ul>
<li>
<p>节省空间的表达式表示形式</p>
</li>
<li>
<p>检测相同表达式重复推导的技术</p>
</li>
<li>
<p>基于缓存的记忆化动态规划</p>
</li>
</ul>
<h4 id="heuristic-optimize">Heuristic Optimize</h4>
<ul>
<li>
<p>尽早执行 Selection</p>
</li>
<li>
<p>尽早执行 Projection</p>
</li>
<li>
<p>尽早执行 条件严苛的指令 来筛选、降低表的大小</p>
</li>
<li>
<p>启发式+其他策略混合（如cost-based）</p>
</li>
<li>
<p>其他策略：只考虑left deep join order，optimization cost budget及时终止优化，plan caching 复用策略</p>
</li>
</ul>
<h4 id="nested-subqueries-optimize">Nested Subqueries Optimize</h4>
<blockquote>
<p><strong>相关变量（correlation variable）：</strong> 外层查询需要传入内层嵌套子查询的变量</p>
<p><strong>相关执行（correlated evaluation）：</strong> 外层对from的表列表直接作笛卡尔积得到所有元组，然后将嵌套子查询视为一个关于相关变量的函数，对每个元组进行check</p>
</blockquote>
<p><img alt="1716732873796" src="../image/Database/1716732873796.png" /></p>
<p>显然上面的方法效率很低，一般尝试将 嵌套子查询 转化为 多连接（注意下面例子的重复元组不同，Join会多一点）</p>
<p><img alt="1716732901355" src="../image/Database/1716732901355.png" /></p>
<ul>
<li>
<p>semijoin ⋉</p>
<ul>
<li>
<p>检查一个结果集（外表）的记录是否在另外一个结果集（字表）中存在匹配记录，本质上半连接仅关注”子表是否存在匹配记录”，而并不考虑”子表存在多少条匹配记录”</p>
<p><img alt="1716733909198" src="../image/Database/1716733909198.png" /></p>
<p>半连接的返回结果集仅使用外表的数据集，查询语句中IN或EXISTS语句常使用半连接来处理</p>
<p><img alt="1716733867727" src="../image/Database/1716733867727.png" /></p>
</li>
<li>
<p>与之对应的还有反半连接anti-semijoin，检查一个结果集（外表）的记录是否在另外一个结果集（字表）中存在匹配记录，当且仅当字表中没有匹配记录时在返回结果集中包含仅使用外表的数据集</p>
</li>
</ul>
</li>
</ul>
<p>借半连接即可将嵌套子查询拆成单级的结构，回到一般的优化问题</p>
<h3 id="materialized-view">Materialized View</h3>
<p>通过一定冗余提高系统效率</p>
<h4 id="materialized-view-maintenance">Materialized View Maintenance</h4>
<blockquote>
<p>维护有 <strong>立即的视图维护（immediate）</strong> 和 <strong>延迟的视图维护（differed）</strong></p>
</blockquote>
<ul>
<li>
<p><em>人工维护</em></p>
</li>
<li>
<p><em>触发器维护</em></p>
</li>
<li>
<p><strong>差分维护：</strong></p>
<p>只需要处理更新的tuple与其他表的数据关系差异（differential）即可，不需要全体重新计算</p>
<p>下面<span class="arithmatex">\(i_r\)</span>指新插入的元组，<span class="arithmatex">\(d_r\)</span>指删除的元组</p>
<ul>
<li>
<p>Join (<span class="arithmatex">\(v = r \Join s\)</span>)</p>
<p><img alt="1716735022061" src="../image/Database/1716735022061.png" /></p>
</li>
<li>
<p>Selection(<span class="arithmatex">\(v = \sigma_{\theta}(r)\)</span>)</p>
<p><img alt="1716735054509" src="../image/Database/1716735054509.png" /></p>
</li>
<li>
<p>Projection(<span class="arithmatex">\(v = \Pi_{A}(r)\)</span>)</p>
<p>使用一个count计数，考虑是否需要更新</p>
</li>
<li>
<p>Aggregation(<span class="arithmatex">\(v = G_F(A,r)\)</span>)</p>
<p>count、sum、avg等都比较好维护，增加一些辅助量即可</p>
<p>min、max可能维护代价太大（删除）</p>
</li>
<li>
<p>Set Operation</p>
<p>根据集合操作的含义维护即可</p>
</li>
<li>
<p>Expression</p>
<p>从小的子表达式开始向上推导</p>
</li>
</ul>
</li>
</ul>
<h4 id="query-optimization">Query Optimization</h4>
<ul>
<li>
<p>替换查询直接利用物化视图</p>
</li>
<li>
<p>使用物化视图的地方替换成其定义，可能获得更高的效率</p>
</li>
</ul>
<h4 id="materialized-view-selection">Materialized View Selection</h4>
<p>类似索引选择，目标都是加速系统的整体效率</p>
<p>具体还得妥善分析系统的工作负载（workload）来决定</p>
<hr />
<h2 id="transaction">十七章 Transaction</h2>
<p>Transaction直译为事务，是一次数据库操作 <strong>若干实际执行的操作</strong> 组成的抽象概念</p>
<p>Transaction的提出主要是为了解决两个问题：</p>
<ul>
<li>
<p>数据库的并发操作，从而提高数据库的性能和效率，具体表现为 吞吐量（throughput）和响应时间（response time）</p>
</li>
<li>
<p>数据库的错误处理（crash recovery）</p>
</li>
</ul>
<h3 id="acid">ACID 原则</h3>
<p>Transation的实现要求四个特性<strong>ACID</strong>：</p>
<ul>
<li>
<p><strong>Automicity原子性</strong>：要么Transaction内的所有操作都成功要么都失败回滚，不允许部分成功部分失败</p>
</li>
<li>
<p><strong>Consistency一致性</strong>：Transaction的发生前后应该保证数据与操作逻辑一致，例如完整性约束、外键约束、逻辑约束等等</p>
</li>
<li>
<p><strong>Isolation隔离性</strong>：Transaction应该对上层隐藏并发实现，无论并发的Transaction在内部以什么顺序执行，都要保证返回的结果正确；并且具体实现过程和并发信息与上层隔离，操作的中间结果对上层也是隐藏的</p>
</li>
<li>
<p><strong>Durability持久性</strong>：数据必须被安全的保存后Transaction才能结束，例如断电等等意外不能对已结束的Transaction的结果数据造成任何影响</p>
</li>
</ul>
<details class="note">
<summary>Transaction定义状态</summary>
<ul>
<li>
<p>Active：正在执行</p>
</li>
<li>
<p>Failed：出现错误，终止</p>
</li>
<li>
<p>Aborted：发生错误之后，正在尝试善后</p>
<ul>
<li>
<p>可能是restart，例如读写的数据页和其他Transaction冲突</p>
</li>
<li>
<p>可能是kill，例如这个Transaction本身不满足一些要求，不可能被顺利执行</p>
</li>
</ul>
</li>
<li>
<p>Partially Committed：逻辑操作已经执行完毕，但是相关数据可能还在buffer或者正在进行写回</p>
</li>
<li>
<p>Committed：数据完整写回，Transaction正式结束</p>
</li>
</ul>
</details>
<h3 id="_33">并发控制</h3>
<p><strong>Schedule</strong>：指并发Transaction的各个子操作在DBMS内部的具体执行步骤。</p>
<ul>
<li>
<p>串行调度：一个一个串行执行事务，只要各事务满足ACID，非常容易保证数据一致但是性能低下。注意在严格的并发语境下，只要没有破坏数据一致性，两个操作无论先执行哪一个都可以认为是正确的</p>
</li>
<li>
<p>并行调度：实际内部并不是先完整执行一个再另一个，性能上限高但是数据很容易不一致</p>
</li>
</ul>
<p>本书并不考虑多条指令并发的“真·并行调度”，只关注我们以什么策略来生成一条<strong>操作</strong>执行序列，满足下列要求</p>
<p><img alt="1717492396907" src="../image/Database/1717492396907.png" /></p>
<h4 id="serializability">Serializability</h4>
<p>每个Transaction可以分为若干次读、运算、写，其中会发生数据不一致（<strong>Conflict</strong>）的只有多个Transaction<strong>并发读写同一个数据</strong>这一种情况（全部只读不会发生冲突，运算由CPU而不是DBMS负责），所以下面我们主要关注有读有写这一种情况</p>
<ul>
<li>
<p>Conflict Serializability</p>
<p>如果S可以通过交换相互不冲突的语句转换为S‘，或者说S与S‘所有相互冲突的Instructions以相同的顺序排列，称S和S‘是<strong>冲突等价（conflict equivalent）</strong>的</p>
<p>如果S冲突等价于一个串行调度序列，称S是<strong>冲突可串行的（conflict serializable）</strong>。</p>
<details class="example">
<summary>Example</summary>
<ul>
<li>
<p>conflict serializable</p>
<p><img alt="1717490106116" src="../image/Database/1717490106116.png" /></p>
</li>
<li>
<p>not conflict serializable</p>
<p><img alt="1717490135297" src="../image/Database/1717490135297.png" /></p>
</li>
</ul>
</details>
</li>
<li>
<p>View Serializability</p>
<p>同样也有 view equivalent, 看着比较复杂，实际上就是考虑每一次的读要符合原来操作顺序的值，并且最后一次写的事务应该保持一致</p>
<p><img alt="1717490766941" src="../image/Database/1717490766941.png" /></p>
<p>容易发现，在这个定义下，view serializability就相当于conflict serializability的一个弱化版，可能存在blind write（未读取而写）问题</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>若考虑运算等一些其他操作，会有除这两者之外的serializability</p>
<p>如下面 schedule<T1,T5></p>
<p><img alt="1717491448315" src="../image/Database/1717491448315.png" /></p>
</div>
</li>
<li>
<p>Precedence Graph</p>
<p><span class="arithmatex">\(T_i \rightarrow T_j\)</span>: <span class="arithmatex">\(\quad T_i\)</span> 与 <span class="arithmatex">\(T_j\)</span>有冲突并且<span class="arithmatex">\(T_i\)</span>先执行</p>
<p>当且仅当Precidence图中无环（注意这是有向图的环）时，某个schedule是冲突可串的（显然可以用topo sort解决）</p>
<p>但对于 视图可串行 的检测属于NP-C问题，因此没有有效算法，只能用一些必要条件进行check</p>
</li>
</ul>
<h4 id="recoverable-schedule">Recoverable Schedule</h4>
<p>如果并发调度下某一个Transaction失败需要回滚会带动其他Transaction一起回滚，称为<strong>级联回滚（cascading rollback）</strong>，如果一个调度序列不会引起任何级联回滚，称它是<strong>非级联序列（cascadeless schedule）</strong></p>
<details class="danger">
<summary>not recoverable</summary>
<p><img alt="1717492088548" src="../image/Database/1717492088548.png" /></p>
</details>
<p>实现非级联序列的具体要求是，并发Transaction们对同一个数据有读有写时，任意<strong>做了写入的Transaction必须先commit，下一个Transaction才能从中读</strong></p>
<h3 id="trade-off">Trade Off</h3>
<p>第一节中就提到了，串行调度数据安全性强而性能弱，并行调度反之。</p>
<p>实际使用中这往往不是一个选择题，通过一些tradeoff(accuracy, week consistency...)取折中。下面列出了常见的四种并行化的层次：</p>
<p><img alt="1717492579162" src="../image/Database/1717492579162.png" /></p>
<details class="note">
<summary>额外控制手段</summary>
<p><img alt="1717492807743" src="../image/Database/1717492807743.png" /></p>
</details>
<h2 id="_34">十八章 并发控制</h2>
<p>前一章从调度原理上介绍了并发控制，而本章是讲解其具体的实现步骤</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Schedules not possible under two-phase locking are possible under the tree protocol, and vice versa.</strong></p>
</div>
<h3 id="lock-based-protocols">Lock-Based Protocols</h3>
<p>锁是Transaction对某个数据的权限申请，由并发管理器控制。</p>
<ul>
<li>
<p><strong>exclusive (X) mode</strong>: Data item can be both read as well as written. X-lock is requested using  <strong>lock-X</strong> instruction.</p>
</li>
<li>
<p><strong>shared (S) mode</strong>: Data item can only be read. S-lock is requested using  <strong>lock-S</strong> instruction.</p>
</li>
</ul>
<p>根据上述逻辑，对某一块数据，没有X锁时可以分享多把S锁给不同Transaction，但是存在一把X锁后就不能再有任何其他锁。这种做法一定程度上避免了混乱的读写</p>
<p><img alt="1717637119400" src="../image/Database/1717637119400.png" /></p>
<h4 id="_35">内部实现</h4>
<details class="note">
<summary>Atomatic Acquisition of Locks</summary>
<p><img alt="1717761635492" src="../image/Database/1717761635492.png" /></p>
<p><img alt="1717761657812" src="../image/Database/1717761657812.png" /></p>
</details>
<p>锁策略一般由lock manager 管理，通过数据结构Lock Table实现，用哈希表归类数据，每个数据下挂链表储存当前锁的请求序列（一般还会为每个事务建立锁链表）</p>
<ul>
<li>
<p>新请求：将新节点挂到链表的后端</p>
</li>
<li>
<p>解锁：从链表中删除对应节点，并检查该节点后续的请求进行处理</p>
</li>
</ul>
<p><img alt="1718692268670" src="../image/Database/1718692268670.png" /></p>
<h4 id="_36">常见问题</h4>
<ul>
<li>
<p><strong>Dead Lock</strong>：锁协议最大的问题是死锁不能被完全避免,比如下图只能通过回滚其中一个Transaction来解决</p>
<p><img alt="1717637451937" src="../image/Database/1717637451937.png" /></p>
</li>
<li>
<p><strong>Startvation</strong>：另一种常见的情况是，派出了过多的S锁，导致出现一个X锁请求时，其会被后面的共享锁所阻塞（排他锁只能等待，而共享锁可以随便加），造成时间浪费</p>
</li>
</ul>
<h4 id="two-phase-lock-protocols">Two-phase Lock Protocols</h4>
<p>为了解决各个Transaction在任意时刻随意加锁解锁带来前一节中提到的问题，出现了二阶段的锁策略：</p>
<ul>
<li>
<p>二阶段锁策略2PL是对单个Transaction而言的</p>
</li>
<li>
<p>两阶段锁强调的是加锁（增长阶段，growing phase）和解锁（缩减阶段，shrinking phase）这两项操作，且每项操作各自为一个阶段</p>
<ul>
<li>
<p>不管同一个事务内需要在多少个数据项上加锁，所有的加锁操作都只能在同一个阶段完成，在这个阶段内，不允许对已经加锁的数据项进行解锁操作。</p>
</li>
<li>
<p>反之，任何一次解锁即视为这个Transaction进入解锁期，此后不允许该Transaction新加任何锁。</p>
</li>
</ul>
</li>
</ul>
<details class="note">
<summary>proof</summary>
<p>We prove by contradiction.</p>
<p>Suppose that there exists a two-phase lock that is not serializable. Then, there must be a cycle in the precedence graph.</p>
<p>Let <span class="arithmatex">\(T_1\rightarrow T_2 \rightarrow \ldots \rightarrow T_n \rightarrow T_1\)</span> be the transactions in the cycle, <span class="arithmatex">\(\alpha_i\)</span> denote the lock point of <span class="arithmatex">\(T_i\)</span>. Then, we have <span class="arithmatex">\(\alpha_1 &lt; \alpha_2 &lt; \ldots &lt; \alpha_n &lt; \alpha_1\)</span>, which is a contradiction.</p>
<p>Therefore, every two-phase lock is serializable.</p>
</details>
<p>二阶段锁策略保证了冲突可串行性，但是不能保证得到的序列是非级联回滚的，因此有了两种衍生策略来解决这个问题：</p>
<ul>
<li>
<p>默认2PL：只要Transaction不需要再申请新锁，并且对某个数据的所有操作都已经完成，那么对这个数据的锁就可以被释放，即使此时Transaction内还有其他操作没有进行</p>
</li>
<li>
<p><strong>Strict Two-phase Locking</strong>：一个Transaction会保留它的X锁直到commit/abort之前</p>
</li>
<li>
<p><strong>Rigorous Two-phase Locking</strong>：一个Transaction会保留它的所有锁直到commit/abort之前</p>
</li>
</ul>
<h3 id="tree-based-protocol-in-graph-based-protocol">Tree-Based Protocol (<span class="arithmatex">\(\in\)</span> Graph-Based Protocol)</h3>
<div class="admonition note">
<p class="admonition-title">Graph-Based Protocol</p>
<p><img alt="1717762311231" src="../image/Database/1717762311231.png" /></p>
</div>
<p>树协议的要求：</p>
<ul>
<li>
<p><em>图结构要是一棵有根树</em></p>
</li>
<li>
<p>Transaction只能申请X锁，并且同一个事务对一个数据只能申锁一次</p>
</li>
<li>
<p>Transaction的第一把锁可以是任何数据项的；接下来，只有该事务持有了数据项的父节点的锁，才可以给数据项加锁</p>
</li>
<li>
<p>数据项可以在任何时候解锁</p>
</li>
</ul>
<p><strong>特性：</strong></p>
<ul>
<li>
<p><strong>保证冲突可串行化</strong></p>
</li>
<li>
<p>相比二阶段锁协议解锁时间自由</p>
</li>
<li>
<p><strong>保证无死锁</strong></p>
</li>
<li>
<p>不保证可恢复性和无联级回滚，但可通过增加限制降低一定并发性来实现</p>
</li>
</ul>
<details class="note">
<summary>trade off</summary>
<ul>
<li>
<p>可恢复性&amp;无联级回滚：事务结束前不允许释放排他锁，但是会降低并发性</p>
</li>
<li>
<p>可恢复性：为每个数据设立 <strong>提交依赖</strong>（对为提交数据的读操作），只有当所有依赖的数据都提交后，即都已经正确写入后，才能提交；当某个数据项被回滚时，所有依赖于它的数据也要回滚</p>
</li>
</ul>
</details>
<p>缺点：</p>
<ul>
<li>有时会给不需要访问的数据项加锁（要求先给父节点加锁），会增加锁开销</li>
</ul>
<h3 id="handling-deadlock">Handling Deadlock</h3>
<details class="example">
<summary>Example</summary>
<p><img alt="1717852620755" src="../image/Database/1717852620755.png" /></p>
</details>
<h4 id="_37">死锁预防</h4>
<blockquote>
<p>通过一些规则避免死锁的发生</p>
</blockquote>
<ul>
<li>
<p><strong>pre-declaration:</strong></p>
<p>在事务执行前一次性申请Transaction需要的所有锁，封锁所有的数据项</p>
<ul>
<li>
<p>事务开始前难以确定需要的锁</p>
</li>
<li>
<p>许多锁可能会被浪费</p>
</li>
</ul>
</li>
<li>
<p><strong>graph-based protocol:</strong></p>
<p>使用图协议给所有的数据项加一个次序，要求事务必须按照这个次序加锁，如前述的树协议</p>
</li>
<li>
<p><strong>Wait-die Scheme</strong></p>
<p>两个事务相互死锁，根据赋予的时间戳，若当前事务先于请求冲突的事务，等待；否则，直接自己回滚滚蛋（先入为主）</p>
<ul>
<li>缺点是回滚后重新计先后，于是后开始的回滚后仍然是后开始的，这有可能导致某个事务一直得不到执行</li>
</ul>
</li>
<li>
<p><strong>Wound-wait Scheme</strong></p>
<p>两个事务相互死锁，根据赋予的时间戳，若当前事务晚于请求冲突的事务，等待；否则，直接回滚自己让位（长江后浪推前浪）</p>
<ul>
<li>缺点是先开始一般意味着已经执行的操作更多，所以回滚的成本更高</li>
</ul>
</li>
<li>
<p><strong>Timeout</strong></p>
<p>为每个事务设置一个超时时间，超时后直接回滚</p>
<ul>
<li>简单粗暴，但是时间难以把握，应用场景有限</li>
</ul>
</li>
</ul>
<h4 id="_38">检测死锁</h4>
<p>用类似前序图的等待图（wait-for graph）关联各个事务,箭头从Ti指向Tj意味着Ti正在等待Tj解锁某个数据，自己才能加锁以继续执行操作。</p>
<p>同样通过检测图中是否有环来判断是否有死锁，有环则有死锁，否则没有。</p>
<div class="admonition danger">
<p class="admonition-title">注意区分</p>
<p>与前序图不同的是，前序图随Schedule的确定而确定，执行过程中不会变化；而等待图在运行过程中时时可能改动</p>
</div>
<h4 id="_39">死锁恢复</h4>
<p>要破坏死锁，只能通过回滚某些事务（victim）</p>
<details class="note">
<summary>Victim Selection</summary>
<ul>
<li>
<p>目前与未来的运算时间估计</p>
</li>
<li>
<p>事务目前与未来使用的资源量估计</p>
</li>
<li>
<p>事务回滚涉及的事务数目</p>
</li>
</ul>
</details>
<ul>
<li>
<p>Total Rollback</p>
<p>彻底回滚选定的事务，然后重新开始</p>
</li>
<li>
<p>Partial Rollback</p>
<p>total rollback可能导致过多不必要的回滚，因此有了partial rollback，只回滚必要的部分，即回滚到消除死锁的状态就停止</p>
</li>
</ul>
<h3 id="multiple-granularity">Multiple Granularity</h3>
<p>Granularity译为粒度,前面锁协议相关内容中，我们将加锁的对象泛指为“数据”，但是实际上“数据“指代的内容量可大可小，组织成一种树形层次结构</p>
<p>如下图所示，从整个数据库到每一个tuple，可以用一个树型结构表示，其中的每一个节点都可以视为“数据”</p>
<p><img alt="1717854468344" src="../image/Database/1717854468344.png" /></p>
<p>通过对多粒度的支持，可以更好地选择加锁策略，从而平衡并发性和性能</p>
<p><img alt="1717854704323" src="../image/Database/1717854704323.png" /></p>
<p>具体实现时，对于每一个加锁请求，我们只需要对其所在的粒度进行 <strong>显示加锁</strong> 即可，而其子节点将会默认被 <strong>隐式加锁</strong>， 则查询时只要访问从根节点到叶子节点的路径上的所有数据项检查锁即可检查这种”隐式锁“；</p>
<p>然而，当要给某个数据项加锁时，我们还得确认其子节点是否已经被加锁而导致“隐式锁”冲突，显然我们不会傻傻地检查整个子树~~（不然多粒度的设计就没有意义了）~~，这里通过引入意向锁（intention lock）来解决这个问题：当某个节点被加锁时，会对从根节点到该节点的路径上的所有节点加上意向锁，这样就可以通过检查节点的意向锁来判断子节点是否被加锁</p>
<p>引入意向锁后的加锁冲突关系图如下（<strong>S/X表示整棵子树的状态，IS/X表示子树内某个节点的状态</strong>）</p>
<p><img alt="1717855249856" src="../image/Database/1717855249856.png" /></p>
<details class="note">
<summary>Note</summary>
<p>多粒度增强了并发性，减少了锁开销</p>
<p>Lock granularity escalation策略: in case there are too many locks at a particular level, switch to higher granularity S or X lock</p>
</details>
<h3 id="other-operations_1">Other Operations</h3>
<h4 id="insertdelete">Insert/Delete</h4>
<ul>
<li>
<p><strong>Insert</strong></p>
<p>插入数据后，需要对新数据项加排他锁，以保证数据的一致性</p>
<p>必须保证新插入的数据不能被其他事务访问，直到插入事务提交</p>
</li>
<li>
<p><strong>Delete</strong></p>
<p>删除数据前，需要对被删除的数据项加排他锁，以保证数据的一致性</p>
<p>必须小心删除操作与读写操作的冲突</p>
</li>
</ul>
<h4 id="predicate-reads">Predicate Reads</h4>
<ul>
<li>
<p>Phantom Phenomenon</p>
<p>本质为一个事务重复读取同一个范围的数据，但是在两次读取之间有另一个事务对数据进行了插入、修改（如将为锁上的数据改为查询的数据）等操作，一般的锁协议无法解决这个问题，从而导致两次读取的数据不一致，成为幻象现象</p>
</li>
<li>
<p><em>暴力解决方案</em></p>
<p>新建一个新数据项，用于记录查询的范围，对所有可能导致幻象现象的数据项加锁</p>
<p>显然会导致大量的锁开销，并大大降低并发性</p>
</li>
<li>
<p><strong>Index Locking</strong></p>
<p>只有当事务在索引的叶结点上找到相应的数据项时，才能真正访问这些数据</p>
<ul>
<li>
<p>朴素做法：</p>
<p>对每个事务访问的所有叶结点索引项都加上共享锁</p>
<p>当要插入、删除、修改数据时，必须更新整个索引，也即需要对所有涉及的叶结点加上排他锁</p>
<p>此外，需要遵循两阶段锁协议</p>
</li>
<li>
<p>Next-Key Locking</p>
<p>由于朴素做法中，需要对整个叶结点加锁，导致并发性能大大降低，为了避免上述问题，引入了Next-Key Locking</p>
<p>谓词查询时，对所有满足条件的 <strong>索引数据项</strong>以及后一个 <strong>索引数据项</strong>加共享锁</p>
<p>插入、删除、修改数据时，对所有满足条件的 <strong>索引数据项</strong>以及后一个 <strong>索引数据项</strong>加排他锁</p>
<p>这样当有幽灵数据出现时，必然会引起锁冲突，从而保证了数据的一致性</p>
<details class="example">
<summary>Example</summary>
<p><img alt="1717857252124" src="../image/Database/1717857252124.png" /></p>
</details>
</li>
</ul>
</li>
</ul>
<h2 id="log-based-recovery">十九章 错误恢复（Log-Based Recovery）</h2>
<h3 id="_40">错误类型</h3>
<ul>
<li>
<p><strong>Transaction Failures</strong></p>
<ul>
<li>
<p>logical errors: 事务逻辑错误，如插入重复数据等</p>
</li>
<li>
<p>system errors: 系统进入不良状态，如死锁</p>
</li>
</ul>
</li>
<li>
<p><strong>System Crash</strong></p>
<blockquote>
<p>fail-stop assumption: 系统在发生错误时会停止运行，易失性数据丢失，非易失性数据不会丢失</p>
</blockquote>
<ul>
<li>
<p>硬件故障</p>
</li>
<li>
<p>软件故障 </p>
</li>
</ul>
</li>
<li>
<p><strong>Disk Failure</strong></p>
<p>数据传输过程中由于磁头损坏等故障导致磁盘块内容丢失</p>
</li>
</ul>
<h3 id="_41">日志</h3>
<p>对每一个事务的每一个update做记录：</p>
<ul>
<li>
<p>Transaction开始时，记录 <code>&lt;Ti start&gt;</code></p>
</li>
<li>
<p>对每一个写操作，记录 <code>&lt;Ti, X, V0, V1&gt;</code>（事务编号Ti，写数据的属性X，原值V0，新值V1）</p>
</li>
<li>
<p>提交时，记录<code>&lt;Ti commit/abort&gt;</code>表示事务结束</p>
</li>
</ul>
<p>在更新时机上又有两种选择：</p>
<ul>
<li>
<p><strong>immediate-modification</strong>：</p>
<ul>
<li>
<p>允许在commit之前将值写入buff/disk</p>
</li>
<li>
<p>数据具体何时、什么顺序真正写入disk是不确定的，交给缓冲区管理器决定 </p>
</li>
</ul>
<div class="admonition warning">
<p class="admonition-title">WAL (Write-Ahead Logging Rule)</p>
<ul>
<li>
<p>为了保证日志的有效性，日志必须在数据写入之前先写入稳定的存储器，再执行相关数据的写操作</p>
</li>
<li>
<p>Commit后数据可以在buff中停留但是Log必须立刻进入Disk等稳定存储器</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>deferred-modification</em>：</p>
<ul>
<li>延迟修改，写操作在commit以前都是在临时变量中做，commit时一次写入buff/disk</li>
</ul>
</li>
</ul>
<p>（本书中我们只讨论immediate的做法）</p>
<h3 id="_42">日志恢复</h3>
<blockquote>
<p>这里只讨论strict two-phase protocol下的恢复</p>
</blockquote>
<h4 id="check-point">Check Point</h4>
<p>重复那些已经写入disk的数据操作是没有意义的。如果每次都从最开始的日志开始恢复，会有大量的重复操作和无用开销。</p>
<p>所以每隔一段时间，我们停止schedule并强制将buff中的所有内容写入disk（包括Log），并在Log中留下一条记录<code>&lt;checkpoint L&gt;</code>作为标记点，记录L为当前还没有被Commit的事务编号（已经Commit的事务再此之前都保证被写入disk了）。</p>
<h4 id="undoredo">Undo/Redo</h4>
<p>一般的恢复过程分为两个阶段：</p>
<p>首先Redo,保证所有数据都被写入（比如commit的数据可能在buff中被损坏了）</p>
<p>然后Undo,将被打断的事务回滚，此时需要留下Compensating Log，记录回滚的操作</p>
<details class="note">
<summary>Compensating Log</summary>
<ul>
<li>
<p>为了处理“恢复时出错，需要从恢复中恢复”的套娃情况，作为额外操作的Undo也需要写Log，这种Log就称为补偿日志</p>
</li>
<li>
<p>一般只需要<code>&lt;Ti, X, V&gt;</code>（事务编号Ti，写数据X，恢复值V）三个信息</p>
</li>
<li>
<p>同时恢复的恢复应该具有<strong>幂等性</strong>，保证在套娃恢复时可以得到正确的结果</p>
<ul>
<li>
<p>A从950恢复到1000：这是幂等的，无论恢复多少次结果都是1000，因此是合适的恢复策略。</p>
</li>
<li>
<p>A加50：这不是幂等的，多次恢复可能导致A的值反复相加，这是不好的恢复策略。</p>
</li>
</ul>
</li>
</ul>
</details>
<ul>
<li>
<p>Redo phase（repeating history）：</p>
<p><img alt="1718269891247" src="../image/Database/1718269891247.png" /></p>
</li>
<li>
<p>Undo phase（reversing history）：</p>
<p><img alt="1718269932712" src="../image/Database/1718269932712.png" /></p>
</li>
</ul>
<details class="note">
<summary>Fuzzy Check Point</summary>
<p>常规Check Point写disk时会强制停止Schedule造成性能浪费，因此有了Fuzzy Checkpoint这一改进策略，相当于每次Checkpoint时将需要写入的数据块记录下来，然后正常执行数据库操作的同时并行写入数据（当数据有冲突时那也没办法只能停了）：</p>
<p><img alt="1718270628055" src="../image/Database/1718270628055.png" /></p>
<p>这样子还需要用一个指针记录当前已经写完的部分，以便在恢复时找到正确的起始点</p>
<p><img alt="1718270705103" src="../image/Database/1718270705103.png" /></p>
</details>
<h4 id="buffers">Buffers</h4>
<ul>
<li>
<p><strong>Log Buffer</strong></p>
<p>上面提到我们总是希望日志被写到Disk中以保证数据可靠，但是这样会对Disk造成很大的压力，所以一般Log也需要Buffer</p>
<p>一般在 缓冲区已满、事务commit、Check Point时将Buffer中的Log写入Disk</p>
<p><img alt="1718270876339" src="../image/Database/1718270876339.png" /></p>
</li>
<li>
<p><strong>Data Buffer</strong></p>
<ul>
<li>
<p>上面提到的恢复算法可以支持下面三种策略：</p>
<ul>
<li>
<p>force policy: 每次commit都要求强制写入Disk，保证数据的可靠性</p>
</li>
<li>
<p>no-force policy: commit时只写入buff，可以等到满了或者Check Point时再写入Disk</p>
</li>
<li>
<p>steal policy: uncommitted数据也可以直接写入Disk</p>
</li>
</ul>
</li>
<li>
<p>写入保护策略（latch）：</p>
<p>在数据块写入时加排他锁，防止其他事务读写</p>
</li>
</ul>
</li>
</ul>
<h3 id="_43">磁盘恢复</h3>
<p>前一节主要解决回滚的实现和易失性存储入Mem的恢复。现在非易失性储存入Disk失效时的恢复：</p>
<ul>
<li>
<p>定期拷贝磁盘作为备份，称Dump</p>
</li>
<li>
<p>类似于Check Point之于内存，恢复时找到最近的Dump和恢复Log，只做Redo</p>
</li>
</ul>
<h3 id="undo">锁的提前释放和逻辑Undo</h3>
<ul>
<li>
<p>逻辑操作</p>
<p>前面仅仅讨论了物理Undo（修改），但是有些操作，比如插入、删除，是无法通过简单物理Undo（即记录旧值和新值）来恢复的，这时候就需要逻辑Undo</p>
<p>并且这些操作在执行时只需要获取一个低级别的瞬时锁，操作完成就可以提前释放，而不用等到事务的释放阶段，以提高并发性</p>
<p>要Undo这些操作，我们需要为每一个操作定义一个反操作，例如插入索引对删除索引，新建表对Drop表等，Undo某个操作即执行它的反操作</p>
</li>
<li>
<p>逻辑日志</p>
<p><img alt="1718277456514" src="../image/Database/1718277456514.png" /></p>
</li>
<li>
<p>恢复算法</p>
<p>对于逻辑Undo，如果该逻辑操作已经完成，那么需要通过其提供的Undo操作来恢复，否则对其中不完整的操作进行物理Undo</p>
<p>并且Logical Undo一定不是幂等的，所以回滚时如果看到Operation-abort，意味着已经逻辑撤回过，不能再次Undo</p>
<p><img alt="1718277661562" src="../image/Database/1718277661562.png" /></p>
<p><img alt="1718277701028" src="../image/Database/1718277701028.png" /></p>
</li>
</ul>
<h3 id="aries">ARIES</h3>
<p><img alt="1718279133705" src="../image/Database/1718279133705.png" /></p>
<h4 id="physiological-redoredo">Physiological Redo（物理逻辑Redo）</h4>
<ul>
<li>
<p>其为物理的，因为会标识出具体的受影响的数据页</p>
</li>
<li>
<p>同时它记录的是逻辑操作，可能可以大大降低日志量</p>
</li>
</ul>
<div class="admonition exmaple">
<p class="admonition-title">Exmaple</p>
<p>删除记录操作，考虑后方数据前移</p>
<p>若采用物理Redo，需要记录所有移动的数据，开销很大</p>
<p>若采用逻辑Redo，只需要记录被删除的元组的数据页和删除操作，恢复时再执行删除操作即可</p>
</div>
<h4 id="aries-data-structure">ARIES Data Structure</h4>
<ul>
<li>
<p><strong>Log Sequence Number (LSN)</strong> </p>
<p>可以看作是Log的身份证号，ARIES将其存在数据页中，越晚标号越大（一般即为数据页号+页内偏移），标识哪些操作已经被实施</p>
</li>
<li>
<p>Page LSN</p>
<p>Buff和Disk等数据页都保存其数据对应的最新的LSN</p>
</li>
<li>
<p>Log Record</p>
<p>常规的Log记录一般包括LSN、事务ID、当前事务的上一条Log的LSN方便便利、操作信息</p>
<p><img alt="1718278805407" src="../image/Database/1718278805407.png" /></p>
<p>还有一种特殊的redo-only log是恢复时的操作，永远不需要undo。为了加快操作，CLR会记录一个UndoNextLSN指向下一个需要Undo的Log，来跳过不需要Undo的Log</p>
<p><img alt="1718278948840" src="../image/Database/1718278948840.png" /></p>
</li>
<li>
<p>Dirty Page Table</p>
<p>在表中保存当前所有的脏页PageID，并记录PageLSN（更改PageID数据的最新LSN），<strong>RecLSN</strong>（修改该Buff的最早的一条Log的LSN</p>
</li>
<li>
<p>CheckPoint Log</p>
<p>记录当前的CheckPoint，包括<strong>Dirty Page Table</strong>和<strong>Active Transaction Table（未提交的事务以及其LastLSN）</strong></p>
<p><em>需要注意的是，ARIES并不在CheckPoint时将所有数据写入Disk，而是让缓存在后台自己刷新</em></p>
</li>
</ul>
<h4 id="aries_1">ARIES具体步骤</h4>
<p>核心是跳过一些不需要的操作，并利用一些指针等加速指令查找</p>
<p><img alt="1718279587109" src="../image/Database/1718279587109.png" /></p>
<ol>
<li>
<p>Analysis Pass：</p>
<ul>
<li>
<p>从最近的Check Point开始，<code>RedoLSN=min(RecLSN, CheckPoint)</code>，<code>UndoList=L</code></p>
</li>
<li>
<p>向下扫描，更新Dirty Page Table和UndoList</p>
<p><img alt="1718279993969" src="../image/Database/1718279993969.png" /></p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>
<p>维护RedoLSN是优化Redo执行的起点</p>
</li>
<li>
<p>记录每个事务的LastLSN优化Undo执行的起点</p>
</li>
</ul>
</div>
</li>
<li>
<p>Redo Pass：</p>
<p>只重做那些真正需要重做的操作，即还没写入磁盘并处于操作期的buffer</p>
<p><img alt="1718280256818" src="../image/Database/1718280256818.png" /></p>
</li>
<li>
<p>Undo Pass：</p>
<p><img alt="1718280887894" src="../image/Database/1718280887894.png" /></p>
<p>看起来非常复杂的操作，本质上就是为了维护相应的指针，加速查找（用<code>max(PrevLSN)</code>作为下一个undo的起点，同时让当前CLR的<code>PrevLSN</code>成为当前事务的上一条，即<code>PrevLSN</code>）</p>
<p><img alt="1718280803888" src="../image/Database/1718280803888.png" /></p>
<div class="admonition note">
<p class="admonition-title">Partial Undo</p>
<p>ARIES支持部分Undo，即只Undo到某个特定的LSN（比如仅仅只是为了破坏死锁），这样可以避免不必要的Undo</p>
</div>
</li>
</ol>
<details class="note">
<summary>其他特征</summary>
<ul>
<li>
<p>恢复独立性（recovery independence）：有些页的恢复可以独立进行</p>
</li>
<li>
<p>保存点（savepoint）：在事务执行过程中，可以设置保存点，以便在回滚时直接回滚到某个保存点</p>
</li>
<li>
<p>细粒度封锁（fine-grained locking）：在恢复时，可以只对需要恢复的数据项加锁，而不是整个事务</p>
</li>
<li>
<p>恢复最优化（recovery optimization）：预先提取数据页、重做推迟等</p>
</li>
</ul>
</details>
<h3 id="_44">基于主存储的恢复</h3>
<p><img alt="1718281501198" src="../image/Database/1718281501198.png" /></p>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["content.code.copy"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.a7c05c9e.min.js"></script>
      
        <script src="../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
        <script src="../javascripts/katex.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.7/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>